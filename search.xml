<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ASCII的最大值</title>
    <url>/posts/24838/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>我们知道，字符类型占一个字节，也就是八位，那平时我们所讲的ASCII范围只是0-127啊，那也就才7位，剩下的那一位呢？</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>我们所讲的是<strong>标准ASCII</strong>，范围是0-127，剩下的那一位是奇偶校验位（有点类似于汉明码），不过后来我们发现，这些字符不太能满足我们的需要，所以就有了<strong>扩展ASCII</strong>，范围是0-255，正好占八位（一个字节），下面摘录一段百度百科的内容。</p>
<h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><p>ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。</p>
<p><font color=green><br>前128个叫标准ASCII 码，也叫基础ASCII码，使用7 位二进制数（剩下的1位二进制为0）来表示有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。</p>
<p><font color=red><br>同时还要注意，在标准ASCII中，其最高位用作奇偶校验位。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种。奇校验规定：正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位添1；偶校验规定：正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位添1  。</p>
<p><font color=green>后128个称为扩展ASCII码。许多基于x86的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号 [1]  。</p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ string 的substr的使用方法</title>
    <url>/posts/20964/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="C-string-的substr的使用方法"><a href="#C-string-的substr的使用方法" class="headerlink" title="C++ string 的substr的使用方法"></a>C++ string 的substr的使用方法</h1><p>直接看代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s = <span class="string">&quot;Hello world !&quot;</span>;</span><br><span class="line">	cout&lt;&lt; s.<span class="built_in">substr</span>(<span class="number">1</span>)&lt;&lt; endl;<span class="comment">//下标从1开始到结束</span></span><br><span class="line">	cout&lt;&lt; s.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">4</span>);<span class="comment">//下标从1开始后4个字符</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><img src="https://img-blog.csdnimg.cn/ac658afbfa6043528de6cb364d11c7ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ sort自定义cmp的细节</title>
    <url>/posts/18623/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<p><font color=red>cmp函数在书写时，一定不要写出“return a &lt;= b”的语句，否则程序就有崩溃的风险，这种错误极难观察出来，所以一定要注意。</p>
<p>关于原因，我看了好多好多博客，这一篇最终解决了我的困惑<br>关键就是一个词：<font color=red>严格弱序比较<font color=black><br>链接：<a href="https://blog.csdn.net/llz62378/article/details/88937139">https://blog.csdn.net/llz62378/article/details/88937139</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>CSDN传送门</title>
    <url>/posts/22989/</url>
    <content><![CDATA[<p>之前在CSDN上写过笔记和题解，这里写一个传送门过去</p>
<p><a href="https://blog.csdn.net/qq_34771124?spm=1000.2115.3001.5343">传送门</a></p>
<p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h5xs6d5m2hj30gm0nxq9z.jpg" alt="image"></p>
]]></content>
      <tags>
        <tag>PAT题解</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 引用和传参的区别</title>
    <url>/posts/13761/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="C-引用和传参的区别"><a href="#C-引用和传参的区别" class="headerlink" title="C++ 引用和传参的区别"></a>C++ 引用和传参的区别</h1><p>直接看代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> *a)</span></span>&#123;</span><br><span class="line">	*a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">func1</span>(a);</span><br><span class="line">	<span class="built_in">func2</span>(b);</span><br><span class="line">	<span class="built_in">func3</span>(&amp;c);</span><br><span class="line">	cout&lt;&lt; a&lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; b&lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; c&lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果<br><img src="https://img-blog.csdnimg.cn/20c10e183dc34558afbd940b3e290bfd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome的headless配置语句（可粘贴）</title>
    <url>/posts/50872/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line"><span class="comment">#path为自己的chrome.exe位置，我这里写的是我自己电脑中的位置</span></span><br><span class="line">path = <span class="string">r&#x27;C:\Users\86185\AppData\Local\Google\Chrome\Application\chrome.exe&#x27;</span></span><br><span class="line">chrome_options.binary_location = path</span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中的内部名和外部名</title>
    <url>/posts/63593/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span><br>​    最近在看C语言的经典书籍——《The C Programming Language》，其中第二章讲到变量名时有这么一段话：“对于内部名而言，至少前31个字符是有效的。函数名与外部变量名包含的字符数目可能小于31，这是因为汇编程序和加载程序可能会使用这些外部名，而语言本身是无法控制加载和汇编程序的。对于外部名，ANSI标准仅保证前6个字符的唯一性，并且不区分大小写。” 怎么也读不懂，于是Google之，得到如下解释：</p>
<p>​    A N S I标准规定，标识符可以为任意长度，但外部名必须至少能由前6个字符唯一地区分，并且不区分大小写。这里外部名指的是在链接过程中所涉及的标识符，其中包括文件间共享的函数名和全局变量名。因此外部名abcdefgh和abcdef将被当作同一个标识符处理，而且abcd和ABCD会当作一样处理。</p>
<p>​    A N S I标准还规定内部名必须至少能由前31个字符唯一地区分。内部名指的是仅出现于定义该标识符的文件中的那些标识符。C语言中的字母是有大小写区别的，因此count Count COUNT是三个不同的标识符。标识符不能和C语言的关键字相同，也不能和用户已编制的函数或C语言库函数同名。</p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>N个有理分数求和</title>
    <url>/posts/34381/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="N个有理分数求和-20-分"><a href="#N个有理分数求和-20-分" class="headerlink" title="N个有理分数求和 (20 分)"></a>N个有理分数求和 (20 分)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>本题的要求很简单，就是求N个数字的和。麻烦的是，这些数字是以有理数分子/分母的形式给出的，你输出的和也必须是有理数的形式。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出一个正整数N（≤100）。随后一行按格式a1/b1 a2/b2 …给出N个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出上述数字和的最简形式 —— 即将结果写成整数部分 分数部分，其中分数部分写成分子/分母，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。</p>
<p><strong>输入样例1</strong>：<br>5<br>2/5 4/15 1/30 -2/60 8/3</p>
<p>输出样例1：<br>3 1/3</p>
<p><strong>输入样例2</strong>：<br>2<br>4/3 2/3</p>
<p><strong>输入样例3</strong><br>3<br>1/3 -1/6 1/8</p>
<p>输出样例3<br>7/24</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>由于是有理数加法，这里可以参照Basic level中的<strong>有理数四则运算</strong><br>（<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805287624491008">题目链接</a>）（<a href="https://blog.csdn.net/qq_34771124/article/details/121479148">题解博客</a>）<br>两个核心：求最大公约数和特殊情况的判断</p>
<h2 id="测试点"><a href="#测试点" class="headerlink" title="测试点"></a>测试点</h2><p>我这个题卡在测试点五<br><strong>运行超时</strong>：那么你在求最大公约数代码中加上这个就好了<br><img src="https://img-blog.csdnimg.cn/417908b7d5aa48548f7136e60cdd7434.png" alt="在这里插入图片描述"><br><strong>浮点错误</strong>：那么你是没有考虑0的情况，一个是求公约数不能出现0，另一个是如果结果为0，只输出一个0就好。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans_up, ans_down;<span class="comment">//分子和分母</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//辗转相除法求最大公约数</span></span><br><span class="line">	<span class="keyword">if</span>(a == b)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">		<span class="type">int</span> c = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a % b == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">	<span class="keyword">else</span>	<span class="keyword">return</span> <span class="built_in">lcd</span>(a - b, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span>&#123;<span class="comment">//计算两个有理数计算的结果</span></span><br><span class="line">	ans_up = a * d + c * b;</span><br><span class="line">	ans_down = b * d;</span><br><span class="line">	<span class="keyword">if</span>(ans_up == <span class="number">0</span>)	<span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> ld = <span class="built_in">lcd</span>(<span class="built_in">abs</span>(ans_up), ans_down);</span><br><span class="line">	ans_up /= ld;</span><br><span class="line">	ans_down /= ld;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="comment">//输出结果</span></span><br><span class="line">	<span class="keyword">if</span>(ans_up &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">		ans_up *= <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ans_up == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans_up &gt;= ans_down)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ans_up % ans_down == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans_up / ans_down);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d/%d&quot;</span>, ans_up / ans_down, ans_up % ans_down, ans_down);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d/%d&quot;</span>, ans_up, ans_down);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ans_up = <span class="number">0</span>, ans_down = <span class="number">1</span>;<span class="comment">//初始化结果</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d/%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="built_in">cal</span>(ans_up, ans_down, x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>GAMES101学习总结</title>
    <url>/posts/27320/</url>
    <content><![CDATA[<center>
今天就正式学完GAMES101了，发篇博客总结一下，顺便纪念一下这个历史性的时刻！
</center>

<span id="more"></span>
<p>图形学目前的学习资源并不多，GAMES101虽然是一门计算机图形学比较好的入门课，但自己由于在这方面毫无基础，这一路学下来还是比较坎坷的，感觉还是遇到了很多困难，大致有这么几个方面：</p>
<ol>
<li>C++基础薄弱，体现在类的使用，引用等等涉及到很多C++特性的东西，由于自己还没有这方面的能力，学习起来真的有点吃力，主要就是作业框架看的也不是很懂，基本都是上网找别人的代码进行一番学习才能勉强看懂，自己现在的安排是大二上一个学期把C++这边的东西学通一遍，参考书是C++ primiar plus（或许是其它），现在立下FLAG，希望到时侯能够实现吧~</li>
<li>没有很好的提问渠道，感觉可能有点孤军奋战，遇到一些问题只能上网去看别人的回答，身边没有一个小伙伴或者是前辈可以请教，这方面总是给自己带来一些困惑，以至于有时候心情和兴趣也会受一定的影响。</li>
</ol>
<p>总结这门课程中学到的东西，总共有以下几个方面：</p>
<ul>
<li>Rasterization（光栅化）与Graphics Pipline（图形管线）</li>
<li>Geometry（几何）</li>
<li>Ray Tracing（光线追踪）</li>
<li>Animation（动画）</li>
</ul>
<p>现在对每个方面都有所了解了，而且作业对于理解的帮助真的好大！目前的打算是接着听金老师安排，继续学习计算机图形学，争取能在这方面做点东西出来！</p>
<p>最后膜拜一下闫令琪大神，真的是太戳我了，是永远值得我去学习的榜样！</p>
<p>最后附上课程资料（课件，作业框架，参考答案），希望能对大家有帮助~</p>
<p>链接：<a href="https://pan.baidu.com/s/1yxST5bsw-OMR39uR-byUYQ">https://pan.baidu.com/s/1yxST5bsw-OMR39uR-byUYQ</a><br>提取码：tpo7<br>—来自百度网盘超级会员V1的分享</p>
<p>附：最后附上金老师的回复吧，还挺让我感到惊喜的，嘿嘿嘿加油！</p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h5pumfgqwpj31gg0dptg7.jpg" alt="image-20220831124437925"></p>
]]></content>
      <tags>
        <tag>CG</tag>
      </tags>
  </entry>
  <entry>
    <title>PTA基础题错题集</title>
    <url>/posts/18805/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><blockquote>
<p>语句int <em>p; </em>p=50;执行时，不会有任何错误<br>分析：有错误，这个指针是空指针，没有对应的地址，直接赋值会出现错误。</p>
</blockquote>
<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><blockquote>
<p>二维数组定义的一般形式如下，其中的类型名指定数组名的类型。 类型名 数组名[行长度][列长度]；<br>分析：错误，类型名指定的是数组中的元素类型。</p>
</blockquote>
<h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><blockquote>
<p>若变量已正确定义并赋值，符合C语言语法的表达式是 __.<br>A.a=2++；<br>B.a=3,5；<br>C.a=a+1=3；<br>D.12.3%4；<br>分析：选B<br>A 2++, 常量不能自加, 错误.<br>B a=3,5等效于a=3, 正确.<br>C a+1=3错误.<br>D%取余运算只能用于整型. 错误</p>
</blockquote>
<h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><blockquote>
<p>运算符“+”不能作为单目运算符。<br>分析：错误，是可以的，表正数的意思</p>
</blockquote>
<h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><blockquote>
<p>表达式 ~( ~2&lt;&lt;1)的值是5。<br>分析：正确，~的优先级高于&lt;&lt;</p>
</blockquote>
<h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><blockquote>
<p>函数f定义如下，执行语句“sum=f(5)+f(3);”后，sum的值应为（ ）。<br>int f(int m)<br>{  static int i=0;<br>   int s=0;<br>     for(;i&lt;=m;i++)<br>     s+=i;<br>return s;<br>}<br>解析：答案为15，原因是静态局部变量的生存周期为整个程序。</p>
</blockquote>
<h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><blockquote>
<p>在定义嵌套的结构类型时，必须先定义成员的结构类型，再定义主结构类型。<br>解析：非常正确。不过有点难懂是什么意思，这里我再讲明白一点。定义嵌套的结构类型，在内部的结构必须在外部结构定义之前被定义一下，否则会报错。<br><img src="https://img-blog.csdnimg.cn/0fba5450ce50413fbdd20f743893eb45.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c34833ec5a0d4b9db1e4df4794feaf64.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
</blockquote>
<h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><blockquote>
<p>全局变量只能定义在程序的最前面，即第一个函数的前面。<br>分析：错误，原因如下：<br><img src="https://img-blog.csdnimg.cn/40bb82d3af4345b7a1305eb34843d76a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>原文链接：<a href="http://c.biancheng.net/view/1858.html">http://c.biancheng.net/view/1858.html</a></p>
</blockquote>
<h1 id="9"><a href="#9" class="headerlink" title="9"></a>9</h1><blockquote>
<p>若变量已正确定义，执行以下while语句将陷入死循环。<br>i = 1;<br>while (i &lt;= 10) ;<br>    i++;<br>   分析：注意第二行末尾的；（阴间考法）</p>
</blockquote>
<h1 id="10"><a href="#10" class="headerlink" title="10"></a>10</h1><blockquote>
<p>下列程序输出结果为？<br>int main(void)<br>{<br>      int  a = 2, b = -1, c = 2;<br>      if(a &lt; b)<br>            if(b &lt; 0)<br>                  c = 0;<br>      else  c++;<br>      printf(“%d\n”,c);<br>      return 0;<br>}<br>解析：else与离他最近的且尚未配对的if配对，因此结果为2</p>
</blockquote>
<h1 id="11"><a href="#11" class="headerlink" title="11"></a>11</h1><blockquote>
<p>设计几组样例？<br>解析：这一类题保证每一个分支和单个条件的每一种都跑到就可以了。（虽然我觉得没有必要）</p>
</blockquote>
<h1 id="12"><a href="#12" class="headerlink" title="12"></a>12</h1><blockquote>
<p>执行以下程序段，输入1.1 0.01 365，输出1.1#0.010#365。<br>int day;<br>double factor, initial;<br>scanf(“%lf %d %lf”, &amp;initial, &amp;factor, &amp;day);<br>printf(“%.1f#%.3f#%d”, initial, factor, day);<br>解析：读入类型不匹配，出错。</p>
</blockquote>
<h1 id="13"><a href="#13" class="headerlink" title="13"></a>13</h1><blockquote>
<p>c语言源程序是文本文件，目标文件和可执行文件是二进制文件。<br>解析：正确。</p>
</blockquote>
<h1 id="14"><a href="#14" class="headerlink" title="14"></a>14</h1><blockquote>
<p>定义FILE *fp; 则文件指针fp 指向的是（）。(2分)<br>A,文件在磁盘上的读写位置<br>B,文件在缓冲区上的读写位置<br>C,整个磁盘文件<br>D,文件类型结构体<br>答案：D</p>
</blockquote>
<h1 id="15"><a href="#15" class="headerlink" title="15"></a>15</h1><blockquote>
<p>在定义结构类型时，关键字struct和它后面的结构名共同组成一个新的数据类型名。<br>正确（不过好像仅限于C，C++里面是可以不写struct的）</p>
</blockquote>
<h1 id="16"><a href="#16" class="headerlink" title="16"></a>16</h1><blockquote>
<p>一个结构类型变量所占的内存空间是其各个成员所占内存空间之和。<br>错误，解析见下面那篇博客。</p>
</blockquote>
<p><font color=red>我转载过一篇博客，说明了这个问题（<a href="https://blog.csdn.net/qq_34771124/article/details/121959579">戳这里</a>）</p>
<h1 id="17"><a href="#17" class="headerlink" title="17"></a>17</h1><blockquote>
<p>C语言 随机操作只适用于文本文件<br>错误。随机操作文本指的是用seek函数重新定位文件指针进行读写操作，访问数组中的元素也是随机的，知道下标就可以，所以说随机操作不只是针对于文件来讲。</p>
</blockquote>
<h1 id="18"><a href="#18" class="headerlink" title="18"></a>18</h1><blockquote>
<p>缓冲文件系统的文件缓冲区位于（）。<br>A.磁盘缓冲区中<br>B.磁盘文件中<br>C.内存数据区中<br>D.程序文件中<br>正确答案：C。文件缓冲区是用以暂时存放读写期间的文件数据而在内存区预留的一定空间</p>
</blockquote>
<h1 id="19"><a href="#19" class="headerlink" title="19"></a>19</h1><blockquote>
<p>函数fgetc的作用是从指定文件读入一个字符，该文件的打开方式必须是（ ）。<br>A.只写<br>B.追加<br>C.读或读写<br>D.答案B和C都正确<br>正确答案：D</p>
</blockquote>
<h1 id="20"><a href="#20" class="headerlink" title="20"></a>20</h1><blockquote>
<p>int *p = 1000;请判断这个语句的正确性<br>答案：错误。在内存中常量的地址不能赋给指针。</p>
</blockquote>
<h1 id="21"><a href="#21" class="headerlink" title="21"></a>21</h1><blockquote>
<p>执行以下程序段，sum的值是1.5。<br>int i, sum;<br>sum = 0;<br>for (i = 1; i &lt;= 2; i++){<br>    sum = sum + 1.0/i;<br>}<br>答案：错误。因为sum定义的类型为int</p>
</blockquote>
<h1 id="22"><a href="#22" class="headerlink" title="22"></a>22</h1><blockquote>
<p>对于以下结构定义，(<em>p)-&gt;str++中的++加在（）。<br>struct {<br>  int len;<br>  char </em>str<br>} *p;<br>答案：语法错误</p>
</blockquote>
<h1 id="23"><a href="#23" class="headerlink" title="23"></a>23</h1><blockquote>
<p>以下程序运行后的输出结果是</p>
<h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<stdio.h></h1><p>void point(char  <em>p)<br>{   p += 3;   }<br>int main( )<br>{<br>  char  b[4] = {‘a’, ‘b’, ‘c’, ‘d’}, </em>p = b;<br>  point(p);<br>  printf(“%c\n”, *p);<br>  return 0;<br>}<br>答案：‘a’。形参和实参的问题。</p>
</blockquote>
<h1 id="24"><a href="#24" class="headerlink" title="24"></a>24</h1><blockquote>
<p>对于 int 型的二级指针变量，它既可以指向同类型的一级指针变量，也可以指向同类型的普通（非指针）变量。<br>答案：错误<br>解析：二级指针间接引用一次后必须是地址值。</p>
</blockquote>
<h1 id="25"><a href="#25" class="headerlink" title="25"></a>25</h1><p>下列程序的运行结果为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">5</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;, *p, **pp;</span><br><span class="line">    </span><br><span class="line">    p = x;</span><br><span class="line">    pp = &amp;p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span> , *(++p));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , (**pp)+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：4,5</p>
<h1 id="26"><a href="#26" class="headerlink" title="26"></a>26</h1><p>写出下列程序段的运行结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *st[] = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>&#125;, **p = st; </span><br><span class="line"></span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s-%c\n&quot;</span>, *p, **p);</span><br><span class="line">(*p)++; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s-%c-%c\n&quot;</span>, *p, **p, (**p)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>第一行：world-w<br>第二行：orld-o-p<br>解析：关键就在（*p）++的理解，其实就是把p指向的地址从原来的world的首地址改为次首地址。</p>
<h1 id="27"><a href="#27" class="headerlink" title="27"></a>27</h1><p>下列程序的输出结果为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="type">int</span> *ptr1 = (<span class="type">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;%x&quot;</span>, ptr1[<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：4<br>解析：&amp;a是一个4大小的数组指针，加一后指向4的下一个位置</p>
<h1 id="28"><a href="#28" class="headerlink" title="28"></a>28</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>  s[ ]=<span class="string">&quot;159&quot;</span>,*p;</span><br><span class="line">    p=s;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*p++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*p++);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序的运行结果为：15<br>解析：++加在距离它最近的变量上（从右往左）</p>
<h1 id="29"><a href="#29" class="headerlink" title="29"></a>29</h1><p>若有函数max(a,b)，并且已使函数指针变量p指向函数max，当调用函数时，正确的调用方法是（ ）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A.</span><br><span class="line">(*p)<span class="built_in">max</span>(a+b);</span><br><span class="line">B.</span><br><span class="line">*<span class="built_in">pmax</span>(a,b);</span><br><span class="line">C.</span><br><span class="line">(*p)(a,b);</span><br><span class="line">D.</span><br><span class="line">*<span class="built_in">p</span>(a,b);</span><br></pre></td></tr></table></figure>
<p>答案：C<br>解析：定义和调用均需要小括号</p>
<h1 id="30"><a href="#30" class="headerlink" title="30"></a>30</h1><p>假设有定义如下： int array[10]; 则该语句定义了一个数组array。其中array的类型是整型指针（即： int <em>）。<br>答案：F<br>原因：应当是数组指针 (int </em>)[10]</p>
<h1 id="31"><a href="#31" class="headerlink" title="31"></a>31</h1><p>对于以下程序，能够正确表示二维数组 t 的元素地址的表达式是（ ）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k, t[<span class="number">3</span>][<span class="number">2</span>], *pt[<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">        pt[k] = t[k];</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A.&amp;t[3][2]<br>B.<em>pt[0]<br>C.</em>(pt+1)<br>D.&amp;pt[2]<br>选择：C<br>t的元素即是t[0] t[1] t[2]……</p>
<h1 id="32"><a href="#32" class="headerlink" title="32"></a>32</h1><p>在 C 程序中，函数既可以嵌套定义，也可以嵌套调用。</p>
<p>答案：F<br>分析：可以嵌套调用，不能嵌套定义</p>
<h1 id="33"><a href="#33" class="headerlink" title="33"></a>33</h1><p>有一段程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    s = <span class="built_in">getSum</span>(k+<span class="number">1</span>) + k;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    sum = <span class="built_in">getSum</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归函数getSum设计不合理，这段程序将无限递归，始终不能结束。</p>
<p>答案：F<br>分析：当堆栈满了之后就会停下来</p>
<h1 id="34"><a href="#34" class="headerlink" title="34"></a>34</h1><p>对于以下程序，能够正确表示二维数组 t 的元素地址的表达式是（ ）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k, t[<span class="number">3</span>][<span class="number">2</span>], *pt[<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">        pt[k] = t[k];</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>A. &amp;t[3][2]</p>
<p>B.*pt[0]</p>
<p>C.*(pt+1)</p>
<p>D.&amp;pt[2]</p>
<p>答案：C<br>解析：题目要求找到一个一级指针<br>        Ａ越界<br>        Ｂ元素的值<br>        Ｃpt[1]一级指针<br>         D 二级指针</p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>course</tag>
      </tags>
  </entry>
  <entry>
    <title>printf输出如何用变量控制位宽</title>
    <url>/posts/23429/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="看代码"><a href="#看代码" class="headerlink" title="看代码"></a>看代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%*d %0*d&quot;</span>, x, y, x, y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>windows批处理学习</title>
    <url>/posts/24536/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span><br><a href="https://www.cnblogs.com/xpwi/p/9626959.html">转载链接</a><br><a href="https://blog.csdn.net/qq_38199187/article/details/84642491">转载链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>一文搞懂结构体变量占用多大的内存空间</title>
    <url>/posts/7270/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="一、首先做一道例题感受一下"><a href="#一、首先做一道例题感受一下" class="headerlink" title="一、首先做一道例题感受一下"></a>一、首先做一道例题感受一下</h1><p>请问下面定义的结构体变量aa在计算机内存中占用多少字节？<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span>   <span class="type">float</span>    height;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span>  age ;</span><br><span class="line">    <span class="type">char</span>     sex ;</span><br><span class="line">&#125;aa;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(aa));  <span class="comment">//屏幕上将显示多少？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>错误解答</strong>：我们都知道，char类型占用1个字节，float型占用4个字节，short int类型占用2个字节，int型在VC6.0中占用4个字节（TC2.0中占用2个字节），long占用8个字节，double占用8个字节。因此，我们可能会犯一个错误就是直接4+2+1=7，结构体aa占用7个字节。这是错的。</p>
<p><strong>错误分析</strong>：计算结构体大小时需要考虑其内存布局，编译系统为了提高计算机访问数据的效率，在安排结构体每个成员的时候采用了内存对齐的方法，具体是：结构体在内存中的存放按单元进行存放，每个单元的大小取决于<font color=red>结构体中最大基本类型的大小。</p>
<h1 id="二、为解释清楚，我们列出以下几种格式"><a href="#二、为解释清楚，我们列出以下几种格式" class="headerlink" title="二、为解释清楚，我们列出以下几种格式"></a>二、为解释清楚，我们列出以下几种格式</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">格式一：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPhone</span>&#123;</span>    </span><br><span class="line"> <span class="type">char</span>   A;    </span><br><span class="line"> <span class="type">int</span>    B;    </span><br><span class="line"> <span class="type">short</span>  C;    </span><br><span class="line">&#125;Phone1;  </span><br><span class="line"></span><br><span class="line">格式二：  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPhone</span>&#123;</span>    </span><br><span class="line"> <span class="type">char</span>   A;    </span><br><span class="line"> <span class="type">short</span>  C;   </span><br><span class="line"> <span class="type">int</span>    B;    </span><br><span class="line">&#125;Phone2;   </span><br><span class="line"></span><br><span class="line">格式三：  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPhone3</span>&#123;</span>    </span><br><span class="line"> <span class="type">char</span>    A;    </span><br><span class="line"> <span class="type">char</span>   B[<span class="number">2</span>];    </span><br><span class="line"> <span class="type">char</span>    C[<span class="number">4</span>];    </span><br><span class="line">&#125;Phone3;   </span><br><span class="line"></span><br><span class="line">格式四：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPhone3</span>&#123;</span>    </span><br><span class="line"> <span class="type">char</span>    A;    </span><br><span class="line"> <span class="type">double</span>  B[<span class="number">2</span>];    </span><br><span class="line"> <span class="type">char</span>    C[<span class="number">4</span>];    </span><br><span class="line">&#125;Phone4;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font size=5>然后我们一一分析<br><img src="https://img-blog.csdnimg.cn/e08eaeeff49e4bb9b8898214f94590b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b53b2ef7e0234d1eb14c2076db3e51dd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/07bc4d274ece44978ae05d013451b9dc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ae67bfa5de134532bdbbebf75d7c7729.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><font color=red>综上所述，作为一个优秀的程序员，有必要在声明结构体变量时考虑如何才能节省空间，因为这之间的差异是非常大的。</p>
<p>原文链接：<a href="http://blog.sina.com.cn/s/blog_75a2ecd20102xca0.html">http://blog.sina.com.cn/s/blog_75a2ecd20102xca0.html</a></p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>一种特殊的算法复杂度分析</title>
    <url>/posts/30513/</url>
    <content><![CDATA[<p>今天看到了DS的HW1拿到了满分，总结一下这次作业学到的：如何分析一种特殊递归函数的复杂度</p>
<script type="math/tex; mode=display">
F(x) = 3F(x / 3) + 1</script><span id="more"></span>
<h2 id="原题展示"><a href="#原题展示" class="headerlink" title="原题展示"></a>原题展示</h2><p>The recurrent equations for the time complexities of programs P1 and P2 are:</p>
<ul>
<li>P1:<em>T</em>(1)=1,<em>T</em>(<em>N</em>)=<em>T</em>(<em>N</em>/3)+1</li>
<li>P2: <em>T</em>(1)=1,<em>T</em>(<em>N</em>)=3<em>T</em>(<em>N</em>/3)+1</li>
</ul>
<p>Then the correct conclusion about their time complexities is:</p>
<p><img src="https://tva3.sinaimg.cn/large/008cRf41ly1h6d9d8kaa0j30ef07jtae.jpg" alt="image" style="zoom:67%;" /></p>
<p><hr></p>
<font color=red>正确答案是B，那是如何推导的呢？</font>

<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>其实这一类的递推函数分析复杂度时，是有一些通性的。也就是说，如果我们掌握了这样的式子如何去推导它的时间复杂度，那么类似的就可以掌握了。</p>
<h3 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h3><p>首先我们来看P1,既然它是一个递推式，那我们不妨往下多写几项</p>
<script type="math/tex; mode=display">
T(N)=T(N/3)+1</script><script type="math/tex; mode=display">
T(N)=[T(N/3^2)+1]+1</script><p>一直往下写，最终的式子应该是</p>
<script type="math/tex; mode=display">
T(N)=T(N/3^k)+k</script><p>这里递归到了最底层，N/3^k的值为1，k=logN，所以我们上面这个式子的复杂度为</p>
<script type="math/tex; mode=display">
O（T(N)）= 1+logN = O（logN）</script><h3 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h3><p>P1和P2的区别是什么呢？我们不难发现，T（N/3）的系数不一样，那它对复杂度的影响是什么样子的呢？</p>
<p>我们不妨学习P1的那种方法，试着写几项</p>
<script type="math/tex; mode=display">
T(N)=3T(N/3)+1</script><script type="math/tex; mode=display">
T(N)=3(3T(N/3^2)+1)+1=3^2T(N/3^2)+3+1</script><script type="math/tex; mode=display">
T(N)=3(3(3(T(N/3^3)+1)+1)+1=3^3T(N/3^3)+3^2+3+1</script><p>一直往下写，最终的式子应该是</p>
<script type="math/tex; mode=display">
T(N)=3^kT(N/3^k)+3^{k-1}+...+3+1</script><p>这里也递归到了最底层，N/3^k的值为1，k=logN，所以我们上面这个式子的复杂度为</p>
<script type="math/tex; mode=display">
T(N)=3^k * 1+3^{k-1}+...+3+1=O(3^k)=O(N)</script><hr>

<center><font color=orange>到这里本文就结束了，如有问题欢迎指出！</font></center>

]]></content>
      <tags>
        <tag>tips</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路算法总结</title>
    <url>/posts/21495/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="最短路算法总结"><a href="#最短路算法总结" class="headerlink" title="最短路算法总结"></a>最短路算法总结</h1><h3 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h3><h5 id="1-Floyd（n-3-n：点数"><a href="#1-Floyd（n-3-n：点数" class="headerlink" title="1.Floyd（n^3) n：点数"></a>1.Floyd（n^3) n：点数</h5><h5 id="2-dijikstra-n-2-gt-mlogm-n：点数-m-边数"><a href="#2-dijikstra-n-2-gt-mlogm-n：点数-m-边数" class="headerlink" title="2.dijikstra( n^2 -&gt; mlogm) n：点数 m:边数"></a>2.dijikstra( n^2 -&gt; mlogm) n：点数 m:边数</h5><h5 id="3-bellman-ford-nm-n-点数-m-边数"><a href="#3-bellman-ford-nm-n-点数-m-边数" class="headerlink" title="3.bellman-ford(nm) n: 点数 m:边数"></a>3.bellman-ford(nm) n: 点数 m:边数</h5><h5 id="4-spfa-Km-K-约为2的常数-m-边数"><a href="#4-spfa-Km-K-约为2的常数-m-边数" class="headerlink" title="4.spfa(Km)  K:约为2的常数 m:边数"></a>4.spfa(Km)  K:约为2的常数 m:边数</h5><h5 id="5-Johnson-nmlogm"><a href="#5-Johnson-nmlogm" class="headerlink" title="5.Johnson (nmlogm)"></a>5.Johnson (nmlogm)</h5><h3 id="二、实现的代码"><a href="#二、实现的代码" class="headerlink" title="二、实现的代码"></a>二、实现的代码</h3><h3 id="1-floyd-全源最短路（可以解决负权边，但不能解决负权回路）"><a href="#1-floyd-全源最短路（可以解决负权边，但不能解决负权回路）" class="headerlink" title="1.floyd  全源最短路（可以解决负权边，但不能解决负权回路）"></a>1.floyd  全源最短路（可以解决负权边，但不能解决负权回路）</h3><p>代码的核心：从第i点到第j点的过程中，寻找是否有第k点（k ！= i &amp;&amp; k ！= j）作为中转点，使得i点和j点之间的最短路可以更新，从而完成代码。</p>
<h2 id="要注意：k要放在最外层循环（本质与动规状态转移有关）否则对于一些神奇的数据点，会出错！！！"><a href="#要注意：k要放在最外层循环（本质与动规状态转移有关）否则对于一些神奇的数据点，会出错！！！" class="headerlink" title="要注意：k要放在最外层循环（本质与动规状态转移有关）否则对于一些神奇的数据点，会出错！！！"></a>要注意：k要放在最外层循环（本质与动规状态转移有关）否则对于一些神奇的数据点，会出错！！！</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200<span class="comment">//基本为最大数据范围</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">//两个点之间的最短距离 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;<span class="comment">//n为点的数目，m为边的数目</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));<span class="comment">//初始化为无穷大</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">		f[i][i] = <span class="number">0</span>;<span class="comment">//自己到自己的距离初始化为0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ m)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">		<span class="keyword">if</span>(z &lt; f[x][y]) f[x][y] = f[y][x] = z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)<span class="comment">//k必须在最外层循环，作为动态转移的状态</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">				<span class="keyword">if</span>(i != k &amp;&amp; i != j &amp;&amp; k != j &amp;&amp; f[x][k] + f[k][y] &lt; f[x][y]) f[x][y] = f[y][x] = f[x][k] + f[k][y];</span><br><span class="line">	f[a][b]即为a,b两点之间的最短距离</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-dijikstra-单源最短路（不能解决负权边）"><a href="#2-dijikstra-单源最短路（不能解决负权边）" class="headerlink" title="2.dijikstra 单源最短路（不能解决负权边）"></a>2.dijikstra 单源最短路（不能解决负权边）</h3><p>使用 优先队列 + vector双重优化，复杂度低于mlogn<br>代码的核心：松弛操作若能实现，将点加入到优先队列中，每次取出距离起点最短距离的点进行拓展，并且保证每个点只进行一次遍历它所有相邻的点。</p>
<p>此处代码直接用堆优化，因为不优化的dijikstra意义不大（时间复杂度高）<br>补充：如何求最短路条数？<br>修改为如下代码即可：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[u] + w &lt; dis[v])&#123;</span><br><span class="line">	dis[v] = dis[u] + w;</span><br><span class="line">	num[v] = num[u];</span><br><span class="line">	que.push(make_pair(-dis[v], v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dis[u] + w == dis[v])</span><br><span class="line">	num[v] += num[u];</span><br></pre></td></tr></table></figure>
<h2 id="注意：压入队列时，要压边权的相反数！（默认大根堆）"><a href="#注意：压入队列时，要压边权的相反数！（默认大根堆）" class="headerlink" title="注意：压入队列时，要压边权的相反数！（默认大根堆）"></a>注意：压入队列时，要压边权的相反数！（默认大根堆）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;<span class="comment">//基本为最大数据范围 </span></span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">vector&lt;pair &lt;<span class="type">int</span> , <span class="type">int</span>&gt; &gt;vec[N];</span><br><span class="line">priority_queue&lt;pair &lt;<span class="type">int</span> , <span class="type">int</span>&gt; &gt;que;<span class="comment">//大根堆 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijikstra</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, x));</span><br><span class="line">	dis[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">top</span>().second;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> len = vec[u].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)&#123;</span><br><span class="line">			<span class="type">int</span> v = vec[u][i].first;</span><br><span class="line">			<span class="type">int</span> w = vec[u][i].second;</span><br><span class="line">			<span class="keyword">if</span>(dis[u] + w &lt; dis[v])&#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[v], v));<span class="comment">//压</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y, v;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;v);</span><br><span class="line">		vec[x].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y, v));</span><br><span class="line">		vec[y].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x, v));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> center;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;center);</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">dijikstra</span>(center);<span class="comment">//求出以center为起点的各点的最短路，存储在dis数组中 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dis[目标点]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-bellman-ford-单源最短路（能解决负权边-不能解决负环，但可以判断负环）"><a href="#3-bellman-ford-单源最短路（能解决负权边-不能解决负环，但可以判断负环）" class="headerlink" title="3.bellman-ford 单源最短路（能解决负权边,不能解决负环，但可以判断负环）"></a>3.bellman-ford 单源最短路（能解决负权边,不能解决负环，但可以判断负环）</h3><p>代码核心：跑n次循环，每次跑m条边的首尾点之间的距离，如果能更新就及时更新。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3050</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Edge&#123;</span><br><span class="line">	<span class="built_in">int</span> u, v;</span><br><span class="line">	<span class="built_in">int</span> w;</span><br><span class="line">&#125;edge[N];<span class="comment">//结构体数组用来存边 </span></span><br><span class="line"><span class="built_in">int</span> dis[N];</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span>&#123;</span><br><span class="line">	<span class="built_in">int</span> U, V;<span class="comment">//起点和终点 </span></span><br><span class="line">	scanf(<span class="string">&quot;%d%d&quot;</span>, &amp;U, &amp;V);</span><br><span class="line">	memset(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">	dis[U] = <span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line">	<span class="built_in">int</span> n, m;</span><br><span class="line">	scanf(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">		scanf(<span class="string">&quot;%d%d%d&quot;</span>, &amp;edge[i].u, &amp;edge[i].v, edge[i].w);</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[edge[j].u] + edge[j].w &lt; dis[edge[j].v])</span><br><span class="line">				dis[edge[j].v] = dis[edge[j].u] + edge[j].w;</span><br><span class="line">			<span class="keyword">if</span>(dis[edge[j].v] + edge[j].w &lt; dis[edge[j].u])</span><br><span class="line">				dis[edge[j].u] = dis[edge[j].v] + edge[j].w;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">		<span class="keyword">if</span>(dis[edge[j].u] + edge[j].w &lt; dis[edge[j].v] || dis[edge[j].v] + edge[j].w &lt; dis[edge[j].u])</span><br><span class="line">			printf(<span class="string">&quot;存在负环！！！&quot;</span>)</span><br><span class="line">	printf(<span class="string">&quot;%d&quot;</span>, dis[V]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-spfa求单源最短路（能解决负权边，不能解决负环，可判断负环）"><a href="#4-spfa求单源最短路（能解决负权边，不能解决负环，可判断负环）" class="headerlink" title="4.spfa求单源最短路（能解决负权边，不能解决负环，可判断负环）"></a>4.spfa求单源最短路（能解决负权边，不能解决负环，可判断负环）</h3><p>代码核心：用队列优化后的bellman-Ford算法，省去了冗余的循环，大大极高运行效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;vec[N];</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;que;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N], d[N];<span class="comment">//d[N]为走最短路到达某点所需步数 </span></span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	vis[s] = <span class="number">1</span>;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">front</span>().second;</span><br><span class="line">		vis[u] = <span class="number">0</span>;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec[u].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">			<span class="type">int</span> v = vec[u][i].first;</span><br><span class="line">			<span class="type">int</span> w = vec[u][i].second;</span><br><span class="line">			<span class="keyword">if</span>(dis[u] + w &lt; dis[v])&#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(d[v] &gt;= n) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//若无负环，走最短路到达某点最多用n-1条边 </span></span><br><span class="line">				<span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">					vis[v] = <span class="number">1</span>;</span><br><span class="line">					que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[v], v));</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);	</span><br><span class="line">	<span class="type">int</span> x, y, z;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">		vec[x].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(y, z));</span><br><span class="line">		vec[y].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(x, z));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> U, V;<span class="comment">//U:起点 V：终点 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;U, &amp;V);</span><br><span class="line">	<span class="type">int</span> judge = <span class="built_in">spfa</span>(U);</span><br><span class="line">	<span class="keyword">if</span>(judge == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;存在负环！！！&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span>	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dis[V]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-johnson全源最短路（能解决负权边，不能解决负环，可以判断负环）"><a href="#5-johnson全源最短路（能解决负权边，不能解决负环，可以判断负环）" class="headerlink" title="5.johnson全源最短路（能解决负权边，不能解决负环，可以判断负环）"></a>5.johnson全源最短路（能解决负权边，不能解决负环，可以判断负环）</h3><p>代码关键：bellman-ford与dijikstra的配合使用，大数据范围下优于spfa算法跑n次。</p>
<p>转载【洛谷日报#242】Johnson 全源最短路径算法学习笔记<br>链接：<a href="https://zhuanlan.zhihu.com/p/99802850">https://zhuanlan.zhihu.com/p/99802850</a></p>
<p>练习题：P5905 【模板】Johnson 全源最短路<br>链接：<a href="https://www.luogu.com.cn/problem/P5905">https://www.luogu.com.cn/problem/P5905</a></p>
<h2 id="建议先看笔记，后做题，下面是本题题解"><a href="#建议先看笔记，后做题，下面是本题题解" class="headerlink" title="建议先看笔记，后做题，下面是本题题解"></a>建议先看笔记，后做题，下面是本题题解</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3005</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], vis[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> u, v;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">&#125;edge[N * <span class="number">2</span>];<span class="comment">//结构体数组用来存边</span></span><br><span class="line">vector&lt;pair &lt;<span class="type">int</span> , <span class="type">int</span>&gt; &gt;vec[N];</span><br><span class="line">priority_queue&lt;pair &lt;<span class="type">long</span> <span class="type">long</span> , <span class="type">int</span>&gt; &gt;que;<span class="comment">//大根堆 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijikstra</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">		dis[i] = <span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, x));</span><br><span class="line">	dis[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u = que.<span class="built_in">top</span>().second;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> len = vec[u].<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)&#123;</span><br><span class="line">			<span class="type">int</span> v = vec[u][i].first;</span><br><span class="line">			<span class="type">int</span> w = vec[u][i].second;</span><br><span class="line">			<span class="keyword">if</span>(dis[u] + w &lt; dis[v])&#123;</span><br><span class="line">				dis[v] = dis[u] + w;</span><br><span class="line">				que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[v], v));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="type">int</span> x, y, z;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">		edge[i].u = x;</span><br><span class="line">		edge[i].v = y;</span><br><span class="line">		edge[i].w = z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(h[edge[j].u] + edge[j].w &lt; h[edge[j].v])</span><br><span class="line">				h[edge[j].v] = h[edge[j].u] + edge[j].w;			</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">		<span class="keyword">if</span>(h[edge[j].u] + edge[j].w &lt; h[edge[j].v])&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">		vec[edge[i].u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(edge[i].v, edge[i].w + h[edge[i].u] - h[edge[i].v]));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)&#123;</span><br><span class="line">		<span class="built_in">dijikstra</span>(i);</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> tot = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[j] == <span class="number">1e9</span>) tot += j * <span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">else</span> tot += j * (dis[j] + h[j] - h[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tot);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="以上就是最短路算法的总结了，或许还是有一些错误的存在，欢迎大家在评论区批评指正，谢谢！"><a href="#以上就是最短路算法的总结了，或许还是有一些错误的存在，欢迎大家在评论区批评指正，谢谢！" class="headerlink" title="以上就是最短路算法的总结了，或许还是有一些错误的存在，欢迎大家在评论区批评指正，谢谢！"></a>以上就是最短路算法的总结了，或许还是有一些错误的存在，欢迎大家在评论区批评指正，谢谢！</h1>]]></content>
      <tags>
        <tag>CS</tag>
        <tag>algorithm</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>关于from selenium import webdriver运行时报错</title>
    <url>/posts/65308/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<p><font color=green><br>首先要成功安装selenium<br><br>我一开始的问题是文件名取了selnium.py<br><br>然后一直报错，改一个其它名即可<br><br>之后，报错就变了</p>
<p><img src="https://img-blog.csdnimg.cn/f2609fd0ee694578a94d7ff607e128fb.png" alt="在这里插入图片描述"></p>
<p><font color=green>也就是说编译器显示都正常，一运行就有bug<br>然后我发现了解决的办法<br>左上角文件-设置-python解释器<br>在其中找到selenium，检查版本<br>如果过新，可能会导致不能正常使用<br>我一开始用的4.1.0，后来改为3.11.0就好了<br><img src="https://img-blog.csdnimg.cn/d643ffbca89146a9b579f2fd7f6e4ff2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><font color=red><br>祝愿你能尽快调出来！QWQ</p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo+github搭建属于自己的博客</title>
    <url>/posts/50751/</url>
    <content><![CDATA[<p>自己最近在学CG（computer graphics）,想到能和前端联系起来，所以就一方面搭建个人网站，另一方面开始学习前端三宝（HTML，CSS，JS），这篇文章是自己搭建这个博客的方法。<br><span id="more"></span></p>
<h2 id="搭建自己的博客网站"><a href="#搭建自己的博客网站" class="headerlink" title="搭建自己的博客网站"></a>搭建自己的博客网站</h2><p>全流程参考知乎文章<a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程 - 知乎 (zhihu.com)</a></p>
<p>如果想要更换主题，不要用上面那篇文章里的教程</p>
<p>用这一个<a href="https://blog.csdn.net/as480133937/article/details/100138838">Hexo-Next 主题博客个性化配置超详细，超全面(两万字)_Z小旋的博客-CSDN博客_hexo next主题配置</a></p>
<p>最后，再说一个我配置的时候遇到的最大的问题，为什么本地预览成功，但是部署到github上后却显示不出来，这里可以这样处理：</p>
<p>首先打开你的github项目</p>
<p>点击settings</p>
<p><img src="https://tvax4.sinaimg.cn/large/008cRf41ly1h5nq4ca5hbj3062042mx3.jpg" alt="image-20220829162224708"></p>
<p>然后打开pages选项</p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h5nq4cg87gj30ed0s5juo.jpg" alt="image-20220829162348247"></p>
<p>然后修改page site从原来的main改为master（如果你是把代码全都部署在master分支上的话，这样可以修改成功</p>
<p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h5nq4clf4mj30ne0fnwiz.jpg" alt="image-20220829162454395"></p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>分辨率的认识</title>
    <url>/posts/28341/</url>
    <content><![CDATA[<p>今天看到了《网页制作从新手到高手》的第四章P50，看到了图像分辨率的介绍，感觉讲的不是很清楚，于是自己搜索，对这个概念有了一些认识，记录为这篇博客</p>
<span id="more"></span>
<h1 id="分辨率的认识"><a href="#分辨率的认识" class="headerlink" title="分辨率的认识"></a>分辨率的认识</h1><h2 id="像素（pixel）"><a href="#像素（pixel）" class="headerlink" title="像素（pixel）"></a>像素（pixel）</h2><p>平时我们经常会接触到一个概念叫做 像素，如何去理解它呢，我们放大一张图片，当放到很大的时候，我们会发现图中变成了各种颜色的色块的组合，这样的每一个色块就叫做一个像素（pixel，简称px）其实我们平时接触到所有的图像都是这样组成的，只不过是我们看一张图片时，通常是从整体来看的，所以我们也不会感觉到有什么异常。</p>
<p>比如我们放大下面这张图里的篮球，就会看到一个个色块，所以其实从更小的角度来看，颜色是离散的（不连续的）</p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h5uvbbpsifj30cf0bg42t.jpg" alt="屏幕截图 2022-09-04 205358"></p>
<p><img src="https://tvax4.sinaimg.cn/large/008cRf41ly1h5uvbc0yhcj31z418g4qp.jpg" alt="屏幕截图 2022-09-04 205629"></p>
<h2 id="图像分辨率与屏幕分辨率"><a href="#图像分辨率与屏幕分辨率" class="headerlink" title="图像分辨率与屏幕分辨率"></a>图像分辨率与屏幕分辨率</h2><h3 id="图像分辨率"><a href="#图像分辨率" class="headerlink" title="图像分辨率"></a>图像分辨率</h3><p>这个概念其实我们平时接触的并不多，当我们说一个图片“像素高” “看起来很清晰”时，其实是在说图像分辨率大，图像分辨率的概念是一英寸正方形内一条边上像素的个数。比如我们在一张图（原始无放大的状态下）画出一个1英寸×1英寸的正方形，然后我们数一下其中的像素个数，如果是72px*72px，那么这个图像的分辨率就是72 ppi（pixels per inch）</p>
<p><img src="https://tvax4.sinaimg.cn/large/008cRf41ly1h5uvi0zpa8j30t90f4dmh.jpg" alt="image"></p>
<center>图片来源 [B站da西先生]([4.分辨率和图像大小_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1UC4y1a7Fx?spm_id_from=333.880.my_history.page.click&vd_source=64137ec6dfc52353d4c023a37a16203e))</center>

<h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>这个我们生活中用的还挺多的，比如我们说这个平板的分辨率是4k的，其实是说这个屏幕的宽上有4000左右个像素点（不同设备会有所区别），还有一种说法是这个屏幕的分辨率是1920 × 1280的，也就是说宽上有1920个像素点，高上有1280个像素点。<br></p>
<p>当屏幕尺寸一定时，分辨率越大，显示效果越好；当分辨率一定时，屏幕越小，显示效果越好。</p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h5uvqccveaj307s04qjs2.jpg" alt="image" style="zoom:200%;" /></p>
<h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p>要注意的是，分辨率并不是图像的文件大小和传输时间最主要的决定因素，因为网页使用的图像是以压缩形式存储的，而且分辨率高 ≠ 图像文件大，像素点越多，图像文件才会越大。</p>
<p>希望能对你有所帮助，如果问题请您批评指出！</p>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>十分钟搞懂C语言文件操作</title>
    <url>/posts/34164/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<p><font color=green><font size=5><br>本文参考：浙大版《C语言程序设计（第4版）》<br><br></p>
<ol>
<li><font color=blue>什么是文件操作</li>
<li><font color=blue>怎么实现基础文件操作</li>
<li><font color=blue>其它文件操作</li>
</ol>
<h1 id="一、什么是文件操作？"><a href="#一、什么是文件操作？" class="headerlink" title="一、什么是文件操作？"></a>一、什么是文件操作？</h1><p>直接来看不太方便理解，我们把它分开。</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件可以通过应用程序创建，如运行“记事本”程序，输入一些数据，然后保存并输入文件名，就会在磁盘中产生一个文本文件。<br><img src="https://img-blog.csdnimg.cn/b93c225bb94c43b392327b7cdcc2afd5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5e41550760314605afe69b1841f46d46.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/49eec3e24e81491d95feb9df85c2bf1b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>刚刚我们创建的只是一种文件，叫做文本文件，还有好多其它类型的文件，每个文件都有==自己的属性==。</p>
<p><font size=5>文件的概念</p>
<p>在操作系统中，文件是指驻留在外部介质（如磁盘等）中的一个==有序数据集==<br>它可以是源文件、目标程序文件、可执行程序，也可以是待输入的原始数据，或是一组输出的结果。</p>
<p><font size=5>文件的分类</p>
<p>源文件、目标文件和可执行程序可称为==程序文件==，输入输出数据可称为==数据文件==。数据文件还可分为各种类型，如<font color=red>文本文件、图像文件、声音文件<font color=black>等。使用应用程序时，通常保存功能实现把数据从内存写入到文件，这就是所谓的（存盘），打开功能实现把磁盘文件的内容读入到内存。</p>
<p><font color=red>我们需要重点关注的类型就是数据文件<br>最直观的例子也就是记事本（可编辑的文本文档）</p>
<p><font size=4><br>如果在用“记事本”程序编辑文件时不“保存”，数据就不会写入到磁盘，即若不保存而直接关闭了应用程序，数据就会消失。实际上，用“记事本”程序编辑文件时，输入的数据先是在内存中，保存后，数据才被写入到磁盘文件中。<br>这其实有点类似我们打游戏时的“存档”，不存档=刚刚的努力白费了</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>我们需要了解的就是读和写两个操作，简单来说</p>
<p><font size=5><br>读：scanf做的事情<br>写：printf做的事情</p>
<p>当上升到文件层面时，“读”就不再是我们平时那样，从键盘读入，而是从数据文件中（最常见的就是记事本）读入；“写”也就是输出，同样地，不会像我们之前写程序那样，显示在屏幕上，而是写在数据文件中（最常见的也是记事本）<br><img src="https://img-blog.csdnimg.cn/e005c92cbebc4a8f96c8d7b69e0a20a6.png" alt="在这里插入图片描述"></p>
<h2 id="那为什么需要文件操作这种东西呢？"><a href="#那为什么需要文件操作这种东西呢？" class="headerlink" title="那为什么需要文件操作这种东西呢？"></a>那为什么需要文件操作这种东西呢？</h2><p>有的人想问，这不是找麻烦吗？我直接ctrl + c / v，运行一下，结果显示在屏幕上，这不是很方便吗？整到记事本里面干什么。<br>其实，文件操作主要是运用于大量数据输入时，可能复制粘贴都得好几秒的那种，屏幕也放不下，那么这个时候用文件操作就很方便啦。</p>
<h1 id="二、怎么实现文件操作？"><a href="#二、怎么实现文件操作？" class="headerlink" title="二、怎么实现文件操作？"></a>二、怎么实现文件操作？</h1><p>直接上代码，用注释帮助理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">具体细节不表</span><br><span class="line">FILE *fp1, *fp2, *fp3;</span><br><span class="line">fp1 = <span class="built_in">fopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">//读</span></span><br><span class="line">fp2 = <span class="built_in">fopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//写</span></span><br><span class="line">/这里进行你的程序读写/</span><br><span class="line">（读入类型一）</span><br><span class="line"><span class="built_in">fscanf</span>(fp1, <span class="string">&quot;%d%lf&quot;</span>, &amp;n, &amp;ft);</span><br><span class="line"><span class="built_in">fprintf</span>(fp2, <span class="string">&quot;%d%f&quot;</span>, n, ft);</span><br><span class="line">（读入类型二）</span><br><span class="line">ch = <span class="built_in">fgetc</span>(fp1);</span><br><span class="line"><span class="built_in">fputc</span>(ch, fp2);</span><br><span class="line">（读入类型三）</span><br><span class="line"><span class="built_in">fgets</span>(s, len, fp1);</span><br><span class="line"><span class="built_in">fputs</span>(s, fp2);</span><br><span class="line">（关闭文件）</span><br><span class="line"><span class="built_in">fclose</span>(fp1);</span><br><span class="line"><span class="built_in">fclose</span>(fp2);</span><br><span class="line">fp3 = <span class="built_in">fopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);<span class="comment">//追加</span></span><br><span class="line"><span class="built_in">fprintf</span>(fp3, <span class="string">&quot;需要补充在后面的东西****&quot;</span>);</span><br><span class="line">(关闭文件)</span><br><span class="line"><span class="built_in">fclost</span>(fp3);</span><br></pre></td></tr></table></figure>
<p>以上就是就是常用的用法，我们接下来从以下几个方面来读懂这个程序</p>
<ol>
<li>FILE</li>
<li>fopen和fclose</li>
<li>fscanf和fprintf</li>
<li>fgetc和fputc</li>
<li>fgets和fputs</li>
</ol>
<h2 id="1-FILE"><a href="#1-FILE" class="headerlink" title="1.FILE"></a>1.FILE</h2><p>简单来写，就是下面这样的（不必搞懂里面的细节）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">　　　　<span class="type">char</span> *_ptr; <span class="comment">//文件输入的下一个位置</span></span><br><span class="line">　　　　<span class="type">int</span> _cnt; <span class="comment">//当前缓冲区的相对位置</span></span><br><span class="line">　　　　<span class="type">char</span> *_base; <span class="comment">//指基础位置(即是文件的起始位置) </span></span><br><span class="line">　　　　<span class="type">int</span> _flag; <span class="comment">//文件标志</span></span><br><span class="line">　　　　<span class="type">int</span> _file; <span class="comment">//文件描述符id</span></span><br><span class="line">　　　　<span class="type">int</span> _charbuf; <span class="comment">//检查缓冲区状况,如果无缓冲区则不读取</span></span><br><span class="line">　　　　<span class="type">int</span> _bufsiz; <span class="comment">//文件缓冲区大小</span></span><br><span class="line">　　　　<span class="type">char</span> *_tmpfname; <span class="comment">//临时文件名</span></span><br><span class="line">  &#125;FILE;</span><br></pre></td></tr></table></figure><br>所以我们知道，FILE是一个结构体类型，我们定义时<br>FILE * fp；<br>其实是定义了一个结构体指针，我们对这个文件指针进行操作时，本质上就对文件进行了操作。</p>
<h2 id="2-fopen和fclose"><a href="#2-fopen和fclose" class="headerlink" title="2.fopen和fclose"></a>2.fopen和fclose</h2><p><font color=red>fopen（“文件名”，文件打开方式）；</p>
<p>例如：fp = fopen(“in.txt”, “r”);</p>
<p>==说明==：(1)该函数有返回值。如果执行成功，函数将返回包含文件缓冲区等信息的FILE结构地址，赋给文件指针fp。否则，返回一个NULL(空值)的FILE指针。<br>(2)括号内包括两个参数：“文件名”和“文件打开方式”。两个参数都是字符串。“文件名”指出要对哪个具体文件进行操作，一般要指定文件的路径，如果不写出路径，则默认与应用程序的当前路径相同。<br><img src="https://img-blog.csdnimg.cn/4ed2d6cce36442e2908789da7513f5b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>我们只讲解了前三种，大家可以借助于此继续理解其它的方式，我们在此就不多赘述。<br>不过重点还是放在==文本文件==（左边一栏），二进制文件用到的情况很少。</p>
<p><font color=red>fclose（文件指针）；.</p>
<p>例如：fclose(fp);</p>
<p>==说明==：fclose的作用就是关闭文件，至于为什么，我们在前面的介绍中也提到过，如果不及时关闭，可能会出现数据保存不成功的问题。<br>此外，你需要知道：<strong>C语言允许一个程序同时打开多个文件，但是不允许同一文件在关闭前被打开，也就是说，你这一次不关，很有可能导致以后再用这个文件时，就打不开。</strong></p>
<h2 id="3-fscanf和fprintf"><a href="#3-fscanf和fprintf" class="headerlink" title="3.fscanf和fprintf"></a>3.fscanf和fprintf</h2><p><font color=red>fscanf（文件指针，格式字符串，输入表)；<br>fprintf（文件指针，格式字符串，输出表)；</p>
<p>例如：<br>fscanf(fp1, “%d%lf”, &amp;n, &amp;ft);<br> fprintf(fp2, “%d%f”, n, ft);</p>
<p>==说明==：其实和scanf和printf差不多，多了一个参数是文件指针。</p>
<h2 id="4-fgetc和fputc"><a href="#4-fgetc和fputc" class="headerlink" title="4.fgetc和fputc"></a>4.fgetc和fputc</h2><p><font color=red><br>fgetc(文件指针)；（返回一个字符）；<br><br>fputc（字符，文件指针）；</p>
<p><br><br>例如：<br><br>ch = fgetc(fp1);<br>fputc(ch, fp2);</p>
<p>==说明==：其实和getchar()和putchar()差不多，多了一个参数是文件指针。</p>
<h2 id="5-fgets和fputs"><a href="#5-fgets和fputs" class="headerlink" title="5.fgets和fputs"></a>5.fgets和fputs</h2><p><font color=red><br>fgets(字符串首地址，想要读入的字符串长度，文件指针)；<br><br>fputs(字符串首地址， 文件指针)；</p>
<p><br><br>例如：<br>fgets(s, len, fp1);<br><br>fputs(s, fp2);<br></p>
<p>==说明== :fgets（）比gets（）多了两个参数，一个是文件指针，一个是想要读入的长度，意思就是你想读进去几个字符存到字符串里，可以用变量来控制.<br>fputs()比puts()也就多了一个参数——文件指针。</p>
<h1 id="三、其它的文件操作（摘自教材）"><a href="#三、其它的文件操作（摘自教材）" class="headerlink" title="三、其它的文件操作（摘自教材）"></a>三、其它的文件操作（摘自教材）</h1><p><img src="https://img-blog.csdnimg.cn/a18c2e0d7fff4749a7c0e4b5593ad5c3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/df72f633aa234a5db7b1611150e3f181.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h1 id="结语：虽然还有好多细节没有展示出来，不过那不影响学会使用文件操作，本文的作用就是帮助大家整理这一块的重要知识，学会用，进而形成自己的知识框架。如果要想深入理解，只靠这一篇博客还是不够的，有必要掌握好一些知识，比如说缓冲文件系统，指针等等。希望这篇博客能对大家有所帮助！"><a href="#结语：虽然还有好多细节没有展示出来，不过那不影响学会使用文件操作，本文的作用就是帮助大家整理这一块的重要知识，学会用，进而形成自己的知识框架。如果要想深入理解，只靠这一篇博客还是不够的，有必要掌握好一些知识，比如说缓冲文件系统，指针等等。希望这篇博客能对大家有所帮助！" class="headerlink" title="结语：虽然还有好多细节没有展示出来，不过那不影响学会使用文件操作，本文的作用就是帮助大家整理这一块的重要知识，学会用，进而形成自己的知识框架。如果要想深入理解，只靠这一篇博客还是不够的，有必要掌握好一些知识，比如说缓冲文件系统，指针等等。希望这篇博客能对大家有所帮助！"></a>结语：虽然还有好多细节没有展示出来，不过那不影响学会使用文件操作，本文的作用就是帮助大家整理这一块的重要知识，学会用，进而形成自己的知识框架。如果要想深入理解，只靠这一篇博客还是不够的，有必要掌握好一些知识，比如说缓冲文件系统，指针等等。希望这篇博客能对大家有所帮助！</h1>]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列（手动与STL实现）</title>
    <url>/posts/24344/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h2 id="栈和队列的总结"><a href="#栈和队列的总结" class="headerlink" title="栈和队列的总结"></a>栈和队列的总结</h2><p><strong>一、栈</strong></p>
<ol>
<li>库函数的栈<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt; <span class="type">int</span> &gt; S; </span><br><span class="line">stack&lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;SS;</span><br><span class="line"></span><br><span class="line">S.<span class="built_in">push</span>(x);入栈</span><br><span class="line">SS.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x, y));入栈</span><br><span class="line">S.<span class="built_in">pop</span>();出栈</span><br><span class="line">S.<span class="built_in">empty</span>()；判断是否为空，若空返回<span class="number">1</span>，不空返回<span class="number">0</span></span><br><span class="line">S.<span class="built_in">size</span>()；栈内元素个数</span><br><span class="line">S.<span class="built_in">top</span>();取出栈顶元素</span><br></pre></td></tr></table></figure></li>
<li>手写栈<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s[];</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">s[++t] = x;入栈</span><br><span class="line">--t; 出栈</span><br><span class="line">t不为<span class="number">0</span>栈则不空</span><br><span class="line">t为栈内元素个数</span><br><span class="line">s[t] 栈顶元素</span><br></pre></td></tr></table></figure>
<strong>二.队列</strong></li>
<li><p>库函数的队列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt; <span class="type">int</span> &gt;que;</span><br><span class="line"></span><br><span class="line">que.<span class="built_in">push</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">back</span>();</span><br><span class="line">que.<span class="built_in">size</span>();</span><br><span class="line">que.<span class="built_in">empty</span>();</span><br><span class="line">标注基本同库函数的栈，此处忽略</span><br></pre></td></tr></table></figure>
</li>
<li><p>手写队列</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">que[];</span><br><span class="line"><span class="type">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">que[++ tail] = x; 加入队列</span><br><span class="line">++head;删除队头</span><br><span class="line">--tail;删除队尾（区别于库函数的操作）</span><br><span class="line">head &gt; tail 队列为空</span><br><span class="line">tail - head 队列元素个数</span><br></pre></td></tr></table></figure>
<p>作者初步整理这些，用于自己日常复习，希望对大家有所帮助。</p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度的渐进表示</title>
    <url>/posts/25658/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="复杂度的渐进表示"><a href="#复杂度的渐进表示" class="headerlink" title="复杂度的渐进表示"></a>复杂度的渐进表示</h1><h2 id="1-O（n）（常用）"><a href="#1-O（n）（常用）" class="headerlink" title="1. O（n）（常用）"></a>1. O（n）（常用）</h2><script type="math/tex; mode=display">T(n)=O(f(n))</script><p>这个式子表示存在常数$C&gt;0$ $n_0 &gt;0$使得当 $n&gt;=n_0$ 时，$T(n)&lt;=C<em>O(f(n))$<br>简单来说，$O(f(n))$ 表示的就是$f(n)$的复杂度中的某个上界<br>例如，$f(n)=(n</em>(n+1))/2$ 则$O(f(n))=n^2$（不唯一）</p>
<h2 id="2-Ω（n）"><a href="#2-Ω（n）" class="headerlink" title="2. Ω（n）"></a>2. Ω（n）</h2><script type="math/tex; mode=display">T(n)=Ω(f(n))</script><p>这个式子表示存在常数$C&gt;0$ $n_0 &gt;0$使得当 $n&gt;=n_0$ 时，$T(n)&gt;=C<em>Ω(f(n))$<br>简单来说，$Ω(f(n))$ 表示的就是$f(n)$的复杂度的某个下界<br>例如，$f(n)=(n</em>(n+1))/2$ 则$Ω(f(n))=n^2/2$（不唯一）</p>
<h2 id="3-Θ（n）"><a href="#3-Θ（n）" class="headerlink" title="3. Θ（n）"></a>3. Θ（n）</h2><script type="math/tex; mode=display">T(n)=Θ(f(n))</script><p>这个式子表示同时有以下两个式子成立<script type="math/tex">T(n)=O(f(n))$$$$T(n)=Ω(f(n))</script></p>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>course</tag>
      </tags>
  </entry>
  <entry>
    <title>复数变量的声明</title>
    <url>/posts/803/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span><br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">头文件 <span class="meta">#include&lt;complex&gt;和using namespace std;</span></span><br><span class="line">complex &lt;<span class="built_in">double</span>&gt; x;</span><br><span class="line">实部：x.real();</span><br><span class="line">虚部：x.imag();</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>如何批量word转pdf</title>
    <url>/posts/53104/</url>
    <content><![CDATA[<p>今天下载bhh老师的PPT，由于都是word格式下载下来的，所以就要统一转化成pdf格式，但是一个个转起来也太麻烦了，所以我上网找到了一个教程，这里做一个简单的搬运和记录<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/368090522">https://zhuanlan.zhihu.com/p/368090522</a><br><span id="more"></span></p>
<h1 id="如何批量word转pdf"><a href="#如何批量word转pdf" class="headerlink" title="如何批量word转pdf"></a>如何批量word转pdf</h1><p>具体流程请参考原文</p>
<p>大概的流程是要在一个空的word文档里打开word的开发者模式，然后打开Virtual Basic，插入模块后，粘上如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sub ConvertWordsToPdfs()</span><br><span class="line">&#x27;Updated by Extendoffice 20181123</span><br><span class="line">Dim xIndex As String</span><br><span class="line">Dim xDlg As FileDialog</span><br><span class="line">Dim xFolder As Variant</span><br><span class="line">Dim xNewName As String</span><br><span class="line">Dim xFileName As String</span><br><span class="line">Set xDlg = Application.FileDialog(msoFileDialogFolderPicker)</span><br><span class="line">If xDlg.Show &lt;&gt; -1 Then Exit Sub</span><br><span class="line">xFolder = xDlg.SelectedItems(1) + &quot;\&quot;</span><br><span class="line">xFileName = Dir(xFolder &amp; &quot;*.*&quot;, vbNormal)</span><br><span class="line">While xFileName &lt;&gt; &quot;&quot;</span><br><span class="line">If ((Right(xFileName, 4)) &lt;&gt; &quot;.doc&quot; Or Right(xFileName, 4) &lt;&gt; &quot;.docx&quot;) Then</span><br><span class="line">xIndex = InStr(xFileName, &quot;.&quot;) + 1</span><br><span class="line">xNewName = Replace(xFileName, Mid(xFileName, xIndex), &quot;pdf&quot;)</span><br><span class="line">Documents.Open FileName:=xFolder &amp; xFileName, _</span><br><span class="line">ConfirmConversions:=False, ReadOnly:=False, AddToRecentFiles:=False, _</span><br><span class="line">PasswordDocument:=&quot;&quot;, PasswordTemplate:=&quot;&quot;, Revert:=False, _</span><br><span class="line">WritePasswordDocument:=&quot;&quot;, WritePasswordTemplate:=&quot;&quot;, Format:= _</span><br><span class="line">wdOpenFormatAuto, XMLTransform:=&quot;&quot;</span><br><span class="line">ActiveDocument.ExportAsFixedFormat OutputFileName:=xFolder &amp; xNewName, _</span><br><span class="line">ExportFormat:=wdExportFormatPDF, OpenAfterExport:=False, OptimizeFor:= _</span><br><span class="line">wdExportOptimizeForPrint, Range:=wdExportAllDocument, From:=1, To:=1, _</span><br><span class="line">Item:=wdExportDocumentContent, IncludeDocProps:=True, KeepIRM:=True, _</span><br><span class="line">CreateBookmarks:=wdExportCreateNoBookmarks, DocStructureTags:=True, _</span><br><span class="line">BitmapMissingFonts:=True, UseISO19005_1:=False</span><br><span class="line">ActiveDocument.Close</span><br><span class="line">End If</span><br><span class="line">xFileName = Dir()</span><br><span class="line">Wend</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>
<p>然后按下F5即可运行</p>
<p>之后选择好根目录文件夹就可以了</p>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决爬虫爬取的不是高清图</title>
    <url>/posts/53990/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<p><font color=red><br>只要把url中的‘_s’删掉即可<br><br>使用以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url = url.replace(&#x27;_s&#x27;, &#x27;&#x27;)</span><br></pre></td></tr></table></figure>
<p><font color=red>快去试试吧！QWQ</p>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>整除光棍（20分）</title>
    <url>/posts/17378/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="整除光棍-20-分"><a href="#整除光棍-20-分" class="headerlink" title="整除光棍 (20 分)"></a>整除光棍 (20 分)</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。</p>
<p>提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在一行中给出一个不以5结尾的正奇数x（&lt;1000）。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出相应的最小的s和n，其间以1个空格分隔。</p>
<p><strong>输入样例</strong>：<br>31<br><strong>输出样例</strong>：<br>3584229390681 15</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a><strong>算法分析</strong></h2><p>本质上就是模拟除法运算，其实有点类似于高精度除法（<a href="https://blog.csdn.net/qq_34771124/article/details/121453990">高精度合集可以参考这里</a>）</p>
<h2 id="测试点"><a href="#测试点" class="headerlink" title="测试点"></a>测试点</h2><p>这个题我一开始卡在了测试点1，其实问题就出在“0”，一共有两种，一种是在商的最前面的0，不能输出，一种是在商中间的“0”，必须输出。<br>这里我为了解决这个问题，用了一个flag来标记是否已经输出一个非0值。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt, x, flag, n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; n)&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag)	<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);<span class="comment">//特判</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x / n);<span class="comment">//输出每一步的除法结果</span></span><br><span class="line">			x %= n;</span><br><span class="line">			<span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		x = x * <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">		cnt ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, cnt);<span class="comment">//输出1的个数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>异或的巧妙使用</title>
    <url>/posts/1322/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="异或的巧妙使用"><a href="#异或的巧妙使用" class="headerlink" title="异或的巧妙使用"></a>异或的巧妙使用</h1><h2 id="题目来源：偶然在网上看到这样一个题目，有很大的学习价值，于是就收录在此了"><a href="#题目来源：偶然在网上看到这样一个题目，有很大的学习价值，于是就收录在此了" class="headerlink" title="题目来源：偶然在网上看到这样一个题目，有很大的学习价值，于是就收录在此了"></a>题目来源：偶然在网上看到这样一个题目，有很大的学习价值，于是就收录在此了</h2><p> <a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247484505&amp;idx=1&amp;sn=4c1c056dd4852c3b4b1ead51c90a9b2d&amp;chksm=fa0e6bd8cd79e2ce8188dcdd8843a5d071248906bfb8971c62d513dbd69b816acc191a78e4b2&amp;scene=21#wechat_redirect">原文链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:<br>输入: [2,2,1]<br>输出: 1</p>
<p>示例 2:<br>输入: [4,1,2,1,2]<br>输出: 4</p>
</blockquote>
<p><br/><br><br/><br><br/></p>
<h3 id="看答案之前，独立思考一下哦！"><a href="#看答案之前，独立思考一下哦！" class="headerlink" title="看答案之前，独立思考一下哦！"></a>看答案之前，独立思考一下哦！</h3><p><br/><br><br/><br><br/></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><blockquote>
<p>时间复杂度不难想O（n），但是能不能用空间复杂度为O（1）的算法解决呢？<br>我们发现，题目中告诉我们，出现的次数只有两种情况：两次和一次。<br>因此我们来想两个相同的数异或结果是多少呢？是0<br>那0和一个非0的数异或呢？就是那个非0的数。<br>所以我们就得到了这样的算法：（⊕ ：异或）<br>将所有元素做异或运算，即a[1] ⊕  a[2] ⊕  a[3] ⊕ …⊕  a[n]，所得的结果就是那个只出现一次的数字。</p>
</blockquote>
<h4 id="是不是非常巧妙？？？"><a href="#是不是非常巧妙？？？" class="headerlink" title="是不是非常巧妙？？？"></a>是不是非常巧妙？？？</h4><h4 id="我们不难得到进一步的思考，只要是-偶数次-和-奇数次-的类似问题，都可以这样解决的。"><a href="#我们不难得到进一步的思考，只要是-偶数次-和-奇数次-的类似问题，都可以这样解决的。" class="headerlink" title="我们不难得到进一步的思考，只要是==偶数次==和==奇数次==的类似问题，都可以这样解决的。"></a>我们不难得到进一步的思考，只要是==偶数次==和==奇数次==的类似问题，都可以这样解决的。</h4><p><br/><br><br/></p>
<h2 id="题目的进阶"><a href="#题目的进阶" class="headerlink" title="题目的进阶"></a>题目的进阶</h2><blockquote>
<p>有一个 n 个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为 O(n) 且再开辟的内存空间固定(与 n 无关)。<br>示例 :<br>输入: [1,2,2,1,3,4]<br>输出: [3,4]</p>
</blockquote>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><blockquote>
<p>我们发现不像刚刚那个题那么简单了，那我们要怎么解决呢？<br>我们本质上考虑一件事情，如果能让这两个数分开来和其它数进行异或<br>那各自的结果不就是我们所求的答案了吗？<br>那我们就来想一个把两个数分开来的方法<br>因为这两个数肯定是互不相同的，所以它们的异或结果一定不为0，我们选择其中一位出来<br>接下来对所有的数跑一次循环，与这一位异或结果为1的所有数进行异或，与这一位抑或结果为0的所有数进行异或，那结果就是我们想要的那两个数了</p>
</blockquote>
<h3 id="同样，这个算法也是非常巧妙，也同样可以扩展到所有的奇数和偶数次的情况。"><a href="#同样，这个算法也是非常巧妙，也同样可以扩展到所有的奇数和偶数次的情况。" class="headerlink" title="同样，这个算法也是非常巧妙，也同样可以扩展到所有的奇数和偶数次的情况。"></a>同样，这个算法也是非常巧妙，也同样可以扩展到所有的奇数和偶数次的情况。</h3><h2 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h2><p>比如两个数的交换（a和b）<br>如何不用另外的变量就实现呢？</p>
<blockquote>
<p>a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;</p>
</blockquote>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样自己亲手搭建一个四比特加法器</title>
    <url>/posts/34487/</url>
    <content><![CDATA[<p><center>大一上《信息与电子工程导论》大作业</center><br><span id="more"></span></p>
<h1 id="怎样自己亲手搭建一个四比特加法器"><a href="#怎样自己亲手搭建一个四比特加法器" class="headerlink" title="怎样自己亲手搭建一个四比特加法器"></a>怎样自己亲手搭建一个四比特加法器</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><font color=green>作为大一上学期第一个大作业，最终还是拖到了冬学期的第八周，从第七周的周六开始，一直到第八周周五上午课上展示，中间连续熬了好几天的夜，另外，白天凡是有时间都用在研究它了，最终大约是用了30个小时，完成了这个四比特加法器的“从零到一”。<br>最终，小组得分92，个人分数100（贡献比35%），也不枉自己投入的心血<br><img src="https://img-blog.csdnimg.cn/a5ced433f0e44b12adf4f1f6b04bc4b7.png" alt="在这里插入图片描述"></p>
<h2 id="二、器材"><a href="#二、器材" class="headerlink" title="二、器材"></a>二、器材</h2><p>电阻 1 包（10kΩ×100，1kΩ×50）<br>三极管 1 包（9013×100，LED×6）<br>跳线 3 短 1.5 长<br>电源 1 个<br>USB 线 1 条<br>面包板 1 块<br>万用表 1 只<br><img src="https://img-blog.csdnimg.cn/8ff0c2bcc7014108866f0512eae094b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="三、步骤"><a href="#三、步骤" class="headerlink" title="三、步骤"></a>三、步骤</h2><p><font color = green><br>1) 利用三极管搭建逻辑门（与或非）并进行仿真测试；<br><br>2) 利用逻辑门搭建一位半加器并进行仿真测试；<br><br>3) 在一位半加器的基础上搭建一位全加器并进行仿真测试；<br><br>4) 利用一位全加器进行适当地级联，搭建 4-bit 加法器，并进行仿真测试；<br><br>5) 进行实物搭建并测试；</p>
<h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><h3 id="1-简单逻辑门的搭建"><a href="#1-简单逻辑门的搭建" class="headerlink" title="1.简单逻辑门的搭建"></a>1.简单逻辑门的搭建</h3><p><img src="https://img-blog.csdnimg.cn/9ae8f673639d43ec887013875bcae933.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/79e28736999644fb9e1895daa5b2cf14.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/83952eb48f1b4535bc6c8eb6eac63e93.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e72f8d73792541ec99c2643613ddb962.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="2-半加器的搭建"><a href="#2-半加器的搭建" class="headerlink" title="2.半加器的搭建"></a>2.半加器的搭建</h3><p><img src="https://img-blog.csdnimg.cn/42005dcedeb7493f9cd11dd05dc3c687.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="最初选择"><br>本质上多了的就是异或门，如何搭建异或门呢？<br>这中间经历了好几代的迭代</p>
<p><font color=red>第一代<br><img src="https://img-blog.csdnimg.cn/ad48b3cbb77f4c5e887f3e46d5d0422b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><font color=black>我们清点一下三极管的数目，发现总共用到七个，而且有很大的损失，必须得改进</p>
<p><font color=red>第二代</p>
<p><font color=black>我们考虑对与非门进行改进(节省一个三极管)<br><img src="https://img-blog.csdnimg.cn/a5b189af6a6d470bbc3635aba681c498.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>仿真结果可知，这样的与非门效果很好，同样的思路我们得到了或非门的改进版，将来在进位中可能会用到。<br><img src="https://img-blog.csdnimg.cn/0c9549156c134c639962ab92d11eb33f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><font color=red>接下来我们搭建半加器</p>
<p><font color=black>考虑到进位的与门有损失的问题，我们搭建时，进位采用了无损与门</p>
<p><font color=blac>无损与门与无损或门<br><img src="https://img-blog.csdnimg.cn/43e631ec8a154e67ab35877a54515ba3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><font color=red>然后我们得到了半加器的电路</p>
<p><img src="https://img-blog.csdnimg.cn/9cc5acb2b24240829b37f6c2edfbd4b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>总共是用到了<strong>七个</strong>三极管，能够完成计算本位（上面的电压表）和进位（下面的电压表）</p>
<p><font color=red>考虑到整个电路的简洁性（三极管越多，电路搭建难度越大），我们对半加器进行进一步的改进<br>本位：或非门结果和与门结果进行或非<br>进位：与门结果<br><img src="https://img-blog.csdnimg.cn/175c804bfe60486db8c2f6c300da06f6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>我们发现只用到了四个三级管，这也是我们最终加法器里面用的半加器方案。</p>
<h3 id="3-全加器的搭建"><a href="#3-全加器的搭建" class="headerlink" title="3.全加器的搭建"></a>3.全加器的搭建</h3><p>在上面四个三极管的基础上，我们进行相应的改进，得到最终的全加器。</p>
<p><font color=blac>本位：两次半加器的本位计算结果（A和B的本位计算结果再与C进位进行本位计算）<br>进位：无损与门（考虑后面的级联问题——损失可能导致结果错误）<br><img src="https://img-blog.csdnimg.cn/2a35aa5463bf45b38a3b9b45873ad1c8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><font color=red>清点一下，我们发现总共用到了10个三极管，同样也是我们的最终版本。</p>
<h3 id="4-半加器与全加器级联实现两位加法器"><a href="#4-半加器与全加器级联实现两位加法器" class="headerlink" title="4.半加器与全加器级联实现两位加法器"></a>4.半加器与全加器级联实现两位加法器</h3><p>其实就是把半加器的进位结果作为全加器的C输入即可。<br><img src="https://img-blog.csdnimg.cn/d6a4361543094fd0a698a06832d622cf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><font color=red>仿真结果<br><img src="https://img-blog.csdnimg.cn/1961b1e2920a4c8aad7dadb189706bce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/6db05306d96d4dfda4cb4f62ecb4078e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/338d1beef189445cbfdfe70624cd1e07.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>我们发现结果完全正确！<br>两位加法器完成！</p>
<h3 id="5-四位加法器的搭建"><a href="#5-四位加法器的搭建" class="headerlink" title="5.四位加法器的搭建"></a>5.四位加法器的搭建</h3><p>其实就是半加器+三个全加器，由于我们之前考虑到了进位有损的问题，所以这里搭建起来也是非常的容易。<br><img src="https://img-blog.csdnimg.cn/e88db013db6e406db97e01bc7c2b8c4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><font color=red>经仿真，我们发现结果依旧完全正确！<br>至此，我们就完成了四位加法器的搭建</p>
<h2 id="五、实物图"><a href="#五、实物图" class="headerlink" title="五、实物图"></a>五、实物图</h2><p><font color=orange></p>
<ol>
<li>与门、或门和非门</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/39e8f333521742149d41dc44fb903f04.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><font color=orange></p>
<ol>
<li>异或门<br><img src="https://img-blog.csdnimg.cn/94fd5b21a7d34ca5be701dc012e9a65e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><font color=orange></li>
<li>与非门<br><img src="https://img-blog.csdnimg.cn/89da0c1d181f41b494347cf098572afc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><font color=orange><br>4.无损与门<br><img src="https://img-blog.csdnimg.cn/16e220237fe8411c88bf0ccab2763702.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><font color=orange></li>
<li>半加器<br><img src="https://img-blog.csdnimg.cn/44c4042a80b542c29cde2ca7ece8478a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><font color=orange></li>
<li>全加器<br><img src="https://img-blog.csdnimg.cn/7f15dc4765c74f4d9ac836e071a46a36.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><font color=orange></li>
<li>两位加法器<br><img src="https://img-blog.csdnimg.cn/c325bbdbbc024b2394ddae72dca67a9a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><font color=orange><br>7.四位加法器<br><img src="https://img-blog.csdnimg.cn/372d7fa9c2714b68ac36e00bbd4d2e4f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li>
</ol>
<h2 id="六、总结与思考"><a href="#六、总结与思考" class="headerlink" title="六、总结与思考"></a>六、总结与思考</h2><p><font color=pink></p>
<ol>
<li>完成一个大作业，需要小组成员合理的分工，这对工作的完成十分重要。<br></li>
<li>建议遵循先仿真后搭建的思路，如果反过来，完成难度大（进位损失须提前考虑）<br></li>
<li>电阻的使用：排电阻用剪刀在红线位置（如下图）剪下，如果拔下的话，管脚会留有胶，易造成接触不良</li>
</ol>
<blockquote>
<p><img src="https://img-blog.csdnimg.cn/a00ba0908aee438885aefa44af4111c0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="这里是引用"></p>
<p><font color=pink><br>4.搭建电路时，可以考虑把一些电阻、三极管的金属段同时插在面包板的同一个孔内，防止因松动导致接触不良。<br><br>5.完成这项作业，也算是帮助我对计算机底层原理有了新的认识，收获满满！</p>
</blockquote>
<h1 id="希望这篇文章对你有所帮助，奥里给QWQ！"><a href="#希望这篇文章对你有所帮助，奥里给QWQ！" class="headerlink" title="希望这篇文章对你有所帮助，奥里给QWQ！"></a>希望这篇文章对你有所帮助，奥里给QWQ！</h1>]]></content>
      <tags>
        <tag>tips</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉筛法及其改进方法（素数的判断）</title>
    <url>/posts/5593/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="素数的筛法（欧拉筛法）及其改进"><a href="#素数的筛法（欧拉筛法）及其改进" class="headerlink" title="素数的筛法（欧拉筛法）及其改进"></a>素数的筛法（欧拉筛法）及其改进</h1><h2 id="欧拉筛法的算法分析："><a href="#欧拉筛法的算法分析：" class="headerlink" title="欧拉筛法的算法分析："></a>欧拉筛法的算法分析：</h2><blockquote>
<pre><code>1.使用一个prime[N]存下当前素数 
2.使用一个on[N]数组标志i 是不是素数。
3.每一个素数都将其当前的i倍数标记为非素数（凡是有因子的数一定不是素数）。
</code></pre><h2 id="处理函数"><a href="#处理函数" class="headerlink" title="处理函数"></a>处理函数</h2></blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	on[<span class="number">0</span>] = on[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//0和1不是素数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!on[i])	prime[++cnt] = i;</span><br><span class="line">				素数存入栈中</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j)&#123;</span><br><span class="line">			on[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">				标记为不是素数</span><br><span class="line">			<span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	此处是精髓，如果当前的i能够被整除，那么这个数之前一定已经被处理过了，</span><br><span class="line">		（欧拉筛法的关键）</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉筛法的关键"><a href="#欧拉筛法的关键" class="headerlink" title="欧拉筛法的关键"></a>欧拉筛法的关键</h2><blockquote>
<p>i % prime[j] == 0 这一步到底有什么用？<br> 答：保证每个数只被它的最小质因子筛一次。（比较难以理解）<br> 我们假设 <strong>i % prime[j] = 0</strong>成立，那么设<strong>k = i / prime[j]</strong> 则prime[j]<em>k = i成立<br>那么对于下一个需要筛选的 i </em> prime[j+1]=prime[j]<em>k</em>prime[j+1]<br>我们令m = k <em>prime[j+1]&gt;  i<br>因此当i增大时，k </em> prime[j+1]肯定会被筛出来的，因此我们这一次就不用处理了<br> 进而我们就保证了每一个非素数只被它的最小质因子筛选一次。</p>
</blockquote>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a><strong>例题</strong></h1><h2 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h2><blockquote>
<p>求1,2,⋯,N 中素数的个数。</p>
</blockquote>
<h2 id="【输入输出格式】"><a href="#【输入输出格式】" class="headerlink" title="【输入输出格式】"></a>【输入输出格式】</h2><blockquote>
<p>【输入】：<br>一个整数N。<br>【输出】：<br>1 个整数，表示素数的个数。<br><strong>注意</strong>:<br>• 对于40% 的数据，1≤ N ≤10 ^6^<br>• 对于80% 的数据，1≤ N ≤10 ^7^<br>• 对于100% 的数据    1≤ N ≤10 ^8^</p>
</blockquote>
<h2 id="【算法分析】"><a href="#【算法分析】" class="headerlink" title="【算法分析】"></a>【算法分析】</h2><p>这么大的数据如果真的要让普通判断方法，那么一定会超时(O（n^2^）).那么就需要一个黑科技来解决——<strong>欧拉筛法</strong>。</p>
<h2 id="【代码实现】"><a href="#【代码实现】" class="headerlink" title="【代码实现】"></a>【代码实现】</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt, n;</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> on[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	on[<span class="number">0</span>] = on[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//0和1不是素数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!on[i])	prime[++cnt] = i;</span><br><span class="line">			<span class="comment">//素数存入栈中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j)&#123;</span><br><span class="line">			on[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//标记为不是素数</span></span><br><span class="line">			<span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//此处是精髓，如果当前的i能够被整除，那么这个数之前一定已经被处理过了，然后直接跳过。（欧拉筛法的关键）</span></span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">  	<span class="keyword">if</span>(!on[i]) tot++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tot);  <span class="comment">//计算数量</span></span><br><span class="line">							<span class="comment">//不过作者此处还有一个思路，就是由于存进去时候是有序的，所以使用一下low_bound()[上一篇博客有使用方法]，或者二分查找也可以的。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="上述代码中on数组和prime数组均为准确的"><a href="#上述代码中on数组和prime数组均为准确的" class="headerlink" title="上述代码中on数组和prime数组均为准确的"></a>上述代码中on数组和prime数组均为准确的</h3><h3 id="on-1-表示不是素数-on-0表示是素数"><a href="#on-1-表示不是素数-on-0表示是素数" class="headerlink" title="(on[] == 1 表示不是素数 on[] ==0表示是素数)"></a>(on[] == 1 表示不是素数 on[] ==0表示是素数)</h3><hr>
<h1 id="2021年后续-欧拉筛法的优化-O-n-2"><a href="#2021年后续-欧拉筛法的优化-O-n-2" class="headerlink" title="2021年后续(欧拉筛法的优化 O(n / 2))"></a>2021年后续(欧拉筛法的优化 O(n / 2))</h1><p>此处只给出处理的函数代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ct, prime[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> on[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(on, <span class="number">1</span>, <span class="built_in">sizeof</span>(on));</span><br><span class="line">	on[<span class="number">0</span>] = on[<span class="number">1</span>] = on[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">	on[<span class="number">2</span>] = <span class="number">1</span>; prime[++ ct] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(on[i])	prime[++ ct] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;=ct &amp;&amp; prime[j] * i &lt;= n; ++ j)&#123;</span><br><span class="line">			on[prime[j] * i] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="built_in">pre</span>(n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ct);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="要注意优化后的代码中on数组对于偶数的标记不准确-但是prime数组依旧准确。"><a href="#要注意优化后的代码中on数组对于偶数的标记不准确-但是prime数组依旧准确。" class="headerlink" title="要注意优化后的代码中on数组对于偶数的标记不准确,但是prime数组依旧准确。"></a>要注意优化后的代码中on数组对于偶数的标记不准确,但是prime数组依旧准确。</h1><p>==(所有的素数中只有2一个偶数)==</p>
]]></content>
      <tags>
        <tag>素数筛</tag>
      </tags>
  </entry>
  <entry>
    <title>最长子序列的长度问题</title>
    <url>/posts/60005/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="最长子序列长度问题（两种方法）"><a href="#最长子序列长度问题（两种方法）" class="headerlink" title="最长子序列长度问题（两种方法）"></a>最长子序列长度问题（两种方法）</h1><h2 id="【题目描述】："><a href="#【题目描述】：" class="headerlink" title="【题目描述】："></a>【题目描述】：</h2><pre><code>Bob 吃完烤串之后又充满了精力，现在 Alice 给了他一个难题：
有一个长度为 n 的有序序列a[i],
但是 Alice 修改了其中某 k个位置的值，得到新序列 b[i].
Bob 拿到序列 b 之后，希望可以改不超过 k 个位置的值
使得 b 序列也满足有序
这个问题对他来说太难了，他想寻求你的帮助你需要告诉他如何修改使得满足要求。
</code></pre><h2 id="【输入格式】："><a href="#【输入格式】：" class="headerlink" title="【输入格式】："></a>【输入格式】：</h2><pre><code>第一行两个整数 n, k，意义如上所述。（0&lt;=n, k&lt;=5000）
接下来一行 n 个整数，第 i个整数表示b[i].
</code></pre><h2 id="【输出格式】："><a href="#【输出格式】：" class="headerlink" title="【输出格式】："></a>【输出格式】：</h2><pre><code>第一行一个整数 t，表示你要修改的次数。需要满足t&lt;=k;
接下来 t行，第 i 行两个整数 
如果有多组解符合要求，输出任意一组即可。你不必最小化 t，只要满足条件即可。
</code></pre><h2 id="【输入输出样例】："><a href="#【输入输出样例】：" class="headerlink" title="【输入输出样例】："></a>【输入输出样例】：</h2><pre><code>输入样例#1： 
5 1
1 2 7 4 5
输出样例#1： 
1
3 3
输入样例#2： 
5 2
1 2 3 4 5
输出样例#2： 
0
输入样例#3：
5 5
5 4 3 2 1
输出样例#3： 
4
1 1
2 1
3 1
4 1
输入样例#4： 
5 0
1 2 3 4 5
输出样例#4：
0
</code></pre><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>实质上是一个最长子序列问题，如果找到最长子序列长度LIS，那么需要进行更改次数为 n-LIS，每次跑循环找到不在LIS中的数据改为前一个或后一个LIS中的数据即可。</p>
<h2 id="【参考代码】："><a href="#【参考代码】：" class="headerlink" title="【参考代码】："></a>【参考代码】：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5005</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN],SK[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  n, k;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k; </span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; ++i)</span><br><span class="line">		cin&gt;&gt;a[i]; </span><br><span class="line">	<span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">	SK[len] = a[<span class="number">1</span>] ;</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">2</span> ; i &lt;= n ; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>( a[i] &gt; SK[len])</span><br><span class="line">			SK[++len] = a[i];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> j = <span class="built_in">lower_bound</span>(SK+<span class="number">1</span>,SK+len+<span class="number">1</span>,a[i])-SK;</span><br><span class="line">			SK[j] = a[i];</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	cout&lt;&lt; n-len &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>( a[i] == SK[cnt] ) cnt++;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout&lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; SK[cnt<span class="number">-1</span>] &lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<hr>
<p><strong>复杂度为O（n^2）</strong><br>朴素算法， 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span><span class="comment">//或者用bits万能库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">1001</span>;</span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lis</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> num[MAX];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++)&#123;</span><br><span class="line">    num[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j] &lt; a[i] &amp;&amp; num[j] + <span class="number">1</span> &gt; num[i])</span><br><span class="line">        <span class="comment">//每次都在这个元素前进行循环，看是否能替换当前最大子序列长度</span></span><br><span class="line">               num[i] = num[j] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="type">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; x; i++)</span><br><span class="line">	    <span class="keyword">if</span>(maxx &lt; num[i])</span><br><span class="line">	        maxx = num[i];</span><br><span class="line">	<span class="keyword">return</span> maxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lis</span>(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.<strong>复杂度为O (nlogn)</strong><br>    复杂度降低主要是利用了二分的思想，代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span><span class="comment">//或者用bits万能库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">200001</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> d[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	d[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">if</span>(a[i]&gt;d[len])</span><br><span class="line">          d[++len]=a[i];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=std::<span class="built_in">lower_bound</span>(d+<span class="number">1</span>,d+len+<span class="number">1</span>,a[i])-d;</span><br><span class="line"><span class="comment">//lower_bound()作用：找到在某有序序列中大于等于x的第一个数的位置，返回该位置的地址；</span></span><br><span class="line"><span class="comment">//upper_bound()作用: 找到在某有序序列中大于x的第一个数的位置，返回该位置的地址；</span></span><br><span class="line">        d[j]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,len);    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="希望这些能够对大家有帮助…………"><a href="#希望这些能够对大家有帮助…………" class="headerlink" title="希望这些能够对大家有帮助…………"></a>希望这些能够对大家有帮助…………</h2>]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>求一个数组的所有子集</title>
    <url>/posts/29338/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="求一个数组的所有子集（经典面试题）"><a href="#求一个数组的所有子集（经典面试题）" class="headerlink" title="求一个数组的所有子集（经典面试题）"></a>求一个数组的所有子集（经典面试题）</h1><h2 id="偶然在网上看到这样一个题，觉得很有意思，总结下来它的算法"><a href="#偶然在网上看到这样一个题，觉得很有意思，总结下来它的算法" class="headerlink" title="偶然在网上看到这样一个题，觉得很有意思，总结下来它的算法"></a>偶然在网上看到这样一个题，觉得很有意思，总结下来它的算法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在给定一个包含N个数的集合，请你输出它的所有子集。<br>注意：题目保证 0 &lt;= N &lt;= 1000000</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p>3<br>1 3 5</p>
<h2 id="输出样例（前后顺序不固定）"><a href="#输出样例（前后顺序不固定）" class="headerlink" title="输出样例（前后顺序不固定）"></a>输出样例（前后顺序不固定）</h2><p>16<br>(空行)<br>1<br>3<br>5<br>1 3<br>1 5<br>3 5<br>1 3 5</p>
<h2 id="得到的思考"><a href="#得到的思考" class="headerlink" title="得到的思考"></a>得到的思考</h2><p>如果我们考虑一个O（N^2）的算法，肯定是过不去的，所以我们来想想其他办法<br>我们高中时学过：一个含有n个元素的集合的子集个数为$2^n$，因此我们联系二进制<br>从$000-111$一共八个数，分别是：<br>$000,001,010,011,100,101,110,111$<br>所以我们就明白了：用1表示这个元素要取，0表示不取，这样我们就完成了输出。</p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>让$i$从$0 - &gt;n-1$跑一趟循环，配合&gt;&gt;和&amp;1把最低二进制位取出来，然后判断对应的元素是否输出就好。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>自下而上与自上而下的归并排序</title>
    <url>/posts/46627/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h2 id="自下而上与自上而下的归并排序"><a href="#自下而上与自上而下的归并排序" class="headerlink" title="自下而上与自上而下的归并排序"></a>自下而上与自上而下的归并排序</h2><h3 id="问题来源：我一开始也没有注意到这一点，直到我做了这个题"><a href="#问题来源：我一开始也没有注意到这一点，直到我做了这个题" class="headerlink" title="问题来源：我一开始也没有注意到这一点，直到我做了这个题"></a>问题来源：我一开始也没有注意到这一点，直到我做了<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805286714327040">这个题</a></h3><p>这个题目中所描述的归并排序是这样的：<img src="https://img-blog.csdnimg.cn/536ff93a94144c81ab71485d24b138d5.png" alt="在这里插入图片描述"><br>也就是说，对于十个元素的情况，比如<br><strong>3 1 2 8 7 5 9 4 6 0</strong><br>相邻元素两两结合后，就成了<br>（3 1）（2 8）（7 5）（9 4）（6 0）<br><strong>一次排序</strong>后为<br>（1 3）（2 8）（5 7）（4 9）（0 6）<br><strong>二次排序</strong>后为<br>（1 2 3 8）（4 5 7 9）（0 6）<br><strong>三次排序</strong>后为<br>（1 2 3 4 5 7 8 9）（0 6）<br><strong>四次排序</strong>后为<br>（0 1 2 3 4 5 6 7 8 9）</p>
<h2 id="以上为“自下而上”的归并排序"><a href="#以上为“自下而上”的归并排序" class="headerlink" title="以上为“自下而上”的归并排序"></a>以上为“自下而上”的归并排序</h2><h2 id="但是！！！"><a href="#但是！！！" class="headerlink" title="但是！！！"></a>但是！！！</h2><h2 id="如果为“自上而下”的归并排序"><a href="#如果为“自上而下”的归并排序" class="headerlink" title="如果为“自上而下”的归并排序"></a>如果为“自上而下”的归并排序</h2><p>(3 1 2 8 7 5 9 4 6 0)<br>第一次递归下去<br>（3 1 2 8 7）（5 9 4 6 0）<br>第二次递归下去<br>（3 1 2）（8 7）（5 9 4）（6 0）<br>第三次递归下去<br>（3 1）（2）（8 ）（7）（5 9）（4）（6）（0）<br>第四次递归下去<br>（3）（1）（2）（8）（7）（5）（9）（4）（6）（0）<br>第一次回溯（<strong>一次排序</strong>后为）<br>（1 3）（2）（7 8）（5 9）（4）（0 6）<br>第二次回溯（<strong>二次排序</strong>后为）<br>（1 2 3）（7 8）（4 5 9）（0 6）<br>第三次回溯（<strong>三次排序</strong>后为）<br>（1 2 3 7 8）（0 4 5 6 9）<br>第四次回溯（<strong>四次排序</strong>后为）<br>（0 1 2 3 4 5 6 7 8 9）</p>
<h2 id="我们不难发现，两次过程中的数组排列情况是不同的"><a href="#我们不难发现，两次过程中的数组排列情况是不同的" class="headerlink" title="我们不难发现，两次过程中的数组排列情况是不同的"></a>我们不难发现，两次过程中的数组排列情况是不同的</h2><h2 id="因此，在归并排序方面，要认识到自上而下与自下而上的区别"><a href="#因此，在归并排序方面，要认识到自上而下与自下而上的区别" class="headerlink" title="因此，在归并排序方面，要认识到自上而下与自下而上的区别"></a>因此，在归并排序方面，要认识到自上而下与自下而上的区别</h2><hr>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_sort_downtoup</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">2</span>;<span class="comment">//最小分割单元 </span></span><br><span class="line">	<span class="keyword">while</span>(t &lt;= n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += t)&#123;</span><br><span class="line">			<span class="built_in">sort</span>(a + i, a + <span class="built_in">min</span>(i + t, n + <span class="number">1</span>));<span class="comment">//注意sort的使用 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*这里可以进行一些操作 */</span> </span><br><span class="line">		t *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_sort_uptodown</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">Merge_sort_uptodown</span>(l, mid);</span><br><span class="line">	<span class="built_in">Merge_sort_uptodown</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="type">int</span> i = l, j = mid + <span class="number">1</span>, t = l;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &lt;= a[j])&#123;</span><br><span class="line">			k[t] = a[i];</span><br><span class="line">			t ++;</span><br><span class="line">			i ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			k[t] = a[j];</span><br><span class="line">			t ++;</span><br><span class="line">			j ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">		k[t] = a[i];</span><br><span class="line">		t ++;</span><br><span class="line">		i ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j &lt;= r)&#123;</span><br><span class="line">		k[t] = a[j];</span><br><span class="line">		t ++;</span><br><span class="line">		j ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; ++ i)</span><br><span class="line">		a[i] = k[i];</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体类型的三种声明方式</title>
    <url>/posts/40650/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>有类型名称且声明的结构体变量直接跟在后面。<br>如果不直接跟在后面声明，接下来就无法声明结构体变量。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;a;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>有类型名称，声明的结构体变量不直接跟在后面。<br>弥补了方法一的缺陷，可以不直接在结构体定义时声明。<br>当然，也可以直接跟在后面声明。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;b;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> a;</span><br></pre></td></tr></table></figure></p>
<p><font color=red>注意：上述代码在C或C++编译环境下都不报错。但是如果写成下面这种形式，在C编译环境下会报错,而在C++下不报错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">node a;</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>自定义变量名称（常用于复杂名称的简化）<br>进阶用法，建议掌握。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;node;</span><br><span class="line">node a;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>获取Xpath的两种方法</title>
    <url>/posts/44935/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="方法一：利用chrome插件Xpath-Helper"><a href="#方法一：利用chrome插件Xpath-Helper" class="headerlink" title="方法一：利用chrome插件Xpath Helper"></a>方法一：利用chrome插件Xpath Helper</h1><p>打开一个网页，按下ctrl+shift+x显示插件<br><img src="https://img-blog.csdnimg.cn/934cd2dc164c470b80ecc4621bcb1d2e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>按F12在“检查”中找到特殊的标签，并在QUERY内输入想要验证的标签<br><img src="https://img-blog.csdnimg.cn/bab147ace3fc4724bf6b11d8747873f3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当result显示为1时，即表明该标签唯一确定你想要的元素</p>
<h1 id="方法二：直接在“检查”页中定位"><a href="#方法二：直接在“检查”页中定位" class="headerlink" title="方法二：直接在“检查”页中定位"></a>方法二：直接在“检查”页中定位</h1><p>按F12打开检查页，然后点击右上角定位键<br><img src="https://img-blog.csdnimg.cn/6f781872a2c74967bb2c9f864462a6ad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>之后在网页中找到你想要的元素并点击<br><img src="https://img-blog.csdnimg.cn/92a0f34c2a6749629d4fb524a67667ae.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后对高亮部分按下鼠标右键，找到copy，然后选择xpath即可<br><img src="https://img-blog.csdnimg.cn/775413910728422281b85bbe9642f8b9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>tips</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统概论 - 课程复习</title>
    <url>/posts/64027/</url>
    <content><![CDATA[<p>9.16:今天就要考计概了，这几天整理了一下自己最近复习时做的笔记，等会考试加油！</p>
<p>9:23:后续 满绩飘过 :)</p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h6ftpdgvskj30cg0dlace.jpg" alt="image"></p>
<span id="more"></span>
<h1 id="计算机系统概论-课程复习"><a href="#计算机系统概论-课程复习" class="headerlink" title="计算机系统概论 - 课程复习"></a>计算机系统概论 - 课程复习</h1><font color=red size=5>注：本文未声明来源的图片均来自于教材</font>

<font color=blue>《Introduction to Computing Systems, 3rd Edition》</font>

<h2 id="Chapter-1-Welcome-aboard"><a href="#Chapter-1-Welcome-aboard" class="headerlink" title="Chapter 1 Welcome aboard"></a>Chapter 1 Welcome aboard</h2><p>本章主要是做了文章内容的概览</p>
<p>需要掌握的点主要有以下几个</p>
<h3 id="Two-Recurring-Themes"><a href="#Two-Recurring-Themes" class="headerlink" title="Two Recurring Themes"></a>Two Recurring Themes</h3><p>①抽象：在B站上的《计算机科学速成课》中有反复提到，其实我们对一个复杂系统的理解，应该是逐层分析，然后抽象出来到更高一层。</p>
<p>②硬件 VS 软件：一个优秀的从业者或者科研人员，应该是二者兼通的。</p>
<h3 id="Two-important-ideas"><a href="#Two-important-ideas" class="headerlink" title="Two important ideas"></a>Two important ideas</h3><p>①所有的计算机都能做同样的事情，只是时间上会有所差别</p>
<p>②从我们的问题到晶体管把问题解决，涉及到层与层之间的转化</p>
<h3 id="How-to-solve-a-problem-Transformations-Between-Layers"><a href="#How-to-solve-a-problem-Transformations-Between-Layers" class="headerlink" title="How to solve a problem / Transformations Between Layers"></a>How to solve a problem / Transformations Between Layers</h3><p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h6g8f7xwd6j30f80kvabk.jpg" alt="image" style="zoom: 67%;" /></p>
<p><b>这里需要注意几点内容</b></p>
<p>①Algorithms的三大特性：definiteness， effective computability， finiteness</p>
<p>②区分不同ISA的三大特点：OPcode， Data types， addressing mode</p>
<h2 id="Chapter-2-Bits-Data-Types-and-Operations"><a href="#Chapter-2-Bits-Data-Types-and-Operations" class="headerlink" title="Chapter 2 Bits, Data Types and Operations"></a>Chapter 2 Bits, Data Types and Operations</h2><h3 id="比特-Bits"><a href="#比特-Bits" class="headerlink" title="比特 Bits"></a>比特 Bits</h3><p>在二进制语境下，一个比特就存储着一位的信息，有电压（或者说电压高到一定范围内）即表示1，无电压（或者说电压低到一定范围内）即表示0</p>
<h3 id="数据类型-Data-Types"><a href="#数据类型-Data-Types" class="headerlink" title="数据类型 Data Types"></a>数据类型 Data Types</h3><h4 id="整数-Integer"><a href="#整数-Integer" class="headerlink" title="整数 Integer"></a>整数 Integer</h4><p>无符号整数的范围是0 ~ 2^k - 1</p>
<p>有符号整数的范围是- 2^(k - 1) ~ 2^(k - 1) - 1</p>
<p><b>如何得到一个负数</b></p>
<p>方法1：首先对它的正数取反，得到反码（1’s Complement）, 然后加1得到补码（2‘s Complement）</p>
<p>方法2：找到它的正数，从低位往高位（从右往左）找到第一个1，然后左边的取反，1以及右边的部分保持不变</p>
<p><b>补码（2’s Complement）的设计</b></p>
<p>这个主要是为了满足A + （-A） = 0，便于我们计算机内部的计算</p>
<h4 id="浮点数-Float-Point"><a href="#浮点数-Float-Point" class="headerlink" title="浮点数 Float Point"></a>浮点数 Float Point</h4><p><b>为什么需要浮点数</b></p>
<p>对于整数而言，我们保证了精确度（precision），但是可以表示的数的范围（range）却非常小，这是我们不希望看到的</p>
<p>所以我们选择了这样一种降低精确度，提高表示范围的浮点数表示方法</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h6g8g25y4nj30rt07fjtm.jpg" alt="image" style="zoom:67%;" /></p>
<h5 id="①标准形式-Normalized-form"><a href="#①标准形式-Normalized-form" class="headerlink" title="①标准形式 Normalized form"></a>①标准形式 Normalized form</h5><p><img src="https://tva3.sinaimg.cn/large/008cRf41ly1h6g8gdchugj30vp03375n.jpg" alt="image" style="zoom:67%;" /></p>
<h5 id="②非标准形式-abnormalized-form"><a href="#②非标准形式-abnormalized-form" class="headerlink" title="②非标准形式 abnormalized form"></a>②非标准形式 abnormalized form</h5><p>当指数部分全为1时（即exponent = 255），我们可以用来表示一些特殊情况，其中包括了无穷大，当小数部分全为0时，表示的就是无穷大，符号位是1则表示负无穷，符号位是0则表示正无穷</p>
<p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h6g8guh41fj3133069qb3.jpg" alt="image"></p>
<h5 id="③亚标准形式-subnormalized-form"><a href="#③亚标准形式-subnormalized-form" class="headerlink" title="③亚标准形式 subnormalized form"></a>③亚标准形式 subnormalized form</h5><p>这个是用来表示标准形式下介于0 和 2^-126之间的数，当指数部分全为0时，则表示属于这种特殊情况</p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h6g8h2uvwsj30hb02v3z4.jpg" alt="image" style="zoom:67%;" /></p>
<h4 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h4><p>ASCII的引入是为了解决电脑的外设与电脑厂商之间的协调问题，引入ASCII后，一个字节大小的数据就可以用来表示键盘上的一个字符，并且也方便显示屏设备识别并输出。</p>
<h4 id="十六进制数-Hexadecimal-Notion"><a href="#十六进制数-Hexadecimal-Notion" class="headerlink" title="十六进制数 Hexadecimal Notion"></a>十六进制数 Hexadecimal Notion</h4><p>它的引入是为了解决二进制数太长的问题，一个二进制数过长可能会导致拼写容易出错，把每四位二进制码转化为十六进制表示，那么缩短了编码长度，就减少了拼写错误</p>
<h3 id="数据类型间的转化-Conversion"><a href="#数据类型间的转化-Conversion" class="headerlink" title="数据类型间的转化 Conversion"></a>数据类型间的转化 Conversion</h3><h4 id="二进制与十进制"><a href="#二进制与十进制" class="headerlink" title="二进制与十进制"></a>二进制与十进制</h4><p>①二进制 -&gt; 十进制 ： 加权求和</p>
<p>②十进制 -&gt; 二进制 ： 除2取余倒序输出</p>
<p>（如果有小数部分，有两种方案，乘2取整数部分法和逐位分割法，要注意的是，大多数小数部分都不能精确表示，只能一步步趋近）</p>
<h3 id="运算-Operation"><a href="#运算-Operation" class="headerlink" title="运算 Operation"></a>运算 Operation</h3><h4 id="加法减法-Addition-and-Subtraction"><a href="#加法减法-Addition-and-Subtraction" class="headerlink" title="加法减法 Addition and Subtraction"></a>加法减法 Addition and Subtraction</h4><p>利用二补数的性质就可轻松完成</p>
<p><b>补充：符号位拓展 Sign-Extension</b>：如果不同位的两个数进行运算，首先要用符号位拓展让他们保持相同的位数，方法是在前面补上足够多的原有符号位。</p>
<p><b>补充：溢出 Overflow</b>：如果两个数运算的结果超出了在十进制下的表示范围，那么我们就称之为溢出</p>
<h4 id="逻辑运算-Logical-Operations"><a href="#逻辑运算-Logical-Operations" class="headerlink" title="逻辑运算 Logical Operations"></a>逻辑运算 Logical Operations</h4><p>这是逐位进行的（Bitwise）</p>
<p>总共有AND，OR， NOT，XOR</p>
<h4 id="比特向量-Bit-Vector"><a href="#比特向量-Bit-Vector" class="headerlink" title="比特向量 Bit Vector"></a>比特向量 Bit Vector</h4><p>这个主要是运用于掩码（Bit mask），比如我们想取出第三位，那么我们就用原来的数与100进行AND，那结果就是我们期望的值</p>
<p>另外还可以用于管理一个复杂系统，用每一位来表示一个对应子模块是否可用（available or busy）</p>
<h2 id="Chapter-3-Digital-Logic-Structures"><a href="#Chapter-3-Digital-Logic-Structures" class="headerlink" title="Chapter 3 Digital Logic Structures"></a>Chapter 3 Digital Logic Structures</h2><h3 id="晶体管-Transistors"><a href="#晶体管-Transistors" class="headerlink" title="晶体管 Transistors"></a>晶体管 Transistors</h3><p>今天我们大多数微处理器都是用的MOS晶体管（metal-oxide semiconductor 金属氧化物半导体），有N型和P型两种。</p>
<font color=red>要注意的是N型MOS管下端接地，P型MOS上端接电源，但是绝对不能给任何一个MOS管同时接上电源和地，这将破坏MOS的结构）</font>

<p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h5yd3rvixij30ah07mt92.jpg" alt="image"></p>
<center>N型MOS管（Gate为1则通路）
</center>
<img src="https://tva3.sinaimg.cn/large/008cRf41ly1h6g95nvjfvj30h50d6js6.jpg" alt="image" style="zoom:67%;" />

<center>P型MOS管（Gate为0则为通路）</center>


<p>关于晶体管的内部原理，不在我们这门课程的讨论范围内，我们可以把MOS简单理解为是一个开关</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h5ycypf1ccj30rl0bbwgp.jpg" alt="image"></p>
<p>NMOS Circuits：只包含N型MOS的电路</p>
<p>PMOS Circuits：只包含P型MOS的电路</p>
<p>CMOS CIrcuits（Complementary MOS Circuits）：既包含N型，也包含P型MOS的电路</p>
<h3 id="基本门电路"><a href="#基本门电路" class="headerlink" title="基本门电路"></a>基本门电路</h3><h4 id="非门（NOT-gate-Inverter）"><a href="#非门（NOT-gate-Inverter）" class="headerlink" title="非门（NOT gate / Inverter）"></a>非门（NOT gate / Inverter）</h4><p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h5yd7kcwvwj30dc0ekabb.jpg" alt="image"></p>
<h4 id="或门（OR-gate）"><a href="#或门（OR-gate）" class="headerlink" title="或门（OR gate）"></a>或门（OR gate）</h4><p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h5yd90lwwyj30o80l3jso.jpg" alt="image"></p>
<h4 id="与门（AND-gate）"><a href="#与门（AND-gate）" class="headerlink" title="与门（AND gate）"></a>与门（AND gate）</h4><p><img src="https://tva3.sinaimg.cn/large/008cRf41ly1h5yd8ld1ccj30ns0l3dh1.jpg" alt="image"></p>
<h4 id="异或门（XOR-gate）"><a href="#异或门（XOR-gate）" class="headerlink" title="异或门（XOR gate）"></a>异或门（XOR gate）</h4><p>实现方式有很多种，书上没写出来，这里我搜集了一些网上的说法</p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h5ydlve21aj30gw09qdgo.jpg" alt="image"></p>
<p>（来源：<a href="https://xiaogd.net/book/spcp/gate/xor-gate-by-nand-gate.html">通过与非门构建异或门 · 从零开始打造一台简易计算机 (xiaogd.net)</a>）</p>
<p>当然我们根据异或门的真值表，很容易利用逻辑完备实现异或门（多路选择器的应用）</p>
<h3 id="组合逻辑电路（Combinational-Logic-Circuits）"><a href="#组合逻辑电路（Combinational-Logic-Circuits）" class="headerlink" title="组合逻辑电路（Combinational Logic Circuits）"></a>组合逻辑电路（Combinational Logic Circuits）</h3><h4 id="解码器（Decoder）"><a href="#解码器（Decoder）" class="headerlink" title="解码器（Decoder）"></a>解码器（Decoder）</h4><p>这个可以用在后面LC-3的OPcode识别中</p>
<p><img src="https://tva3.sinaimg.cn/large/008cRf41ly1h5ydov9nahj30g20fiwg2.jpg" alt="image"></p>
<h4 id="多路选择器（Mux）"><a href="#多路选择器（Mux）" class="headerlink" title="多路选择器（Mux）"></a>多路选择器（Mux）</h4><p><img src="https://tvax4.sinaimg.cn/large/008cRf41ly1h5ydsmanigj30s90g5tap.jpg" alt="image"></p>
<h4 id="加法器（Adder）"><a href="#加法器（Adder）" class="headerlink" title="加法器（Adder）"></a>加法器（Adder）</h4><p><img src="https://tva4.sinaimg.cn/large/008cRf41ly1h5ydu0cffjj312k0patie.jpg" alt="image"></p>
<h4 id="可编程逻辑元（Programmable-Logic-Array-PLA）"><a href="#可编程逻辑元（Programmable-Logic-Array-PLA）" class="headerlink" title="可编程逻辑元（Programmable Logic Array / PLA）"></a>可编程逻辑元（Programmable Logic Array / PLA）</h4><p>其实也就是多路选择器的一种扩展</p>
<h4 id="逻辑完备（Logical-completeness）"><a href="#逻辑完备（Logical-completeness）" class="headerlink" title="逻辑完备（Logical completeness）"></a>逻辑完备（Logical completeness）</h4><p>其实意思就是对于任何一种电路的真值表，都可以通过与或非的搭配组合表示出来，其实也是多路选择器的应用</p>
<h3 id="时序逻辑电路（Sequential-Logic-Circuits）"><a href="#时序逻辑电路（Sequential-Logic-Circuits）" class="headerlink" title="时序逻辑电路（Sequential Logic Circuits）"></a>时序逻辑电路（Sequential Logic Circuits）</h3><h4 id="基本存储单元"><a href="#基本存储单元" class="headerlink" title="基本存储单元"></a>基本存储单元</h4><h5 id="R-S-Latch"><a href="#R-S-Latch" class="headerlink" title="R-S Latch"></a>R-S Latch</h5><p>a端为输出端，b端为非a</p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h5ydzp3p2pj30au07x74k.jpg" alt="image"></p>
<p><img src="https://tvax4.sinaimg.cn/large/008cRf41ly1h5ye2mrv1vj30vt0lrwm1.jpg" alt="image" style="zoom:50%;" /></p>
<h5 id="D-Latch"><a href="#D-Latch" class="headerlink" title="D Latch"></a>D Latch</h5><p>相当于是R-S Latch的改进版</p>
<p>改进的思路是加上一个WE（write enable）</p>
<p>当它为0时 R=1 S=1，保持稳定；当它为1时 D端的内容就直接写入输出端a</p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h6g8lww0gdj30o209it9s.jpg" alt="image" style="zoom:50%;" /></p>
<h5 id="Master-Slave-Flipflop"><a href="#Master-Slave-Flipflop" class="headerlink" title="Master-Slave Flipflop"></a>Master-Slave Flipflop</h5><p>主从触发器，相当于是D Latch的一种改进，改进的原因是在处理器处理指令时，通常是同步处理的（synchronous)，每次的操作都在一个时钟周期内完成（Clock），所以如果D端的内容改变，那OUT端立马就会发生改变，这是我们不期望得到的，因为我们这个时候可能正在使用输出端的值，我们需要它保持一段时间的稳定。解决方法是把两个D Latch套在一起，再加上Clock信号即可。</p>
<p><img src="https://tva4.sinaimg.cn/large/008cRf41ly1h6g8m8ha9nj30uh0jgthg.jpg" alt="image" style="zoom:67%;" /></p>
<h4 id="存储的概念"><a href="#存储的概念" class="headerlink" title="存储的概念"></a>存储的概念</h4><p>（用身边的例子比特和字节来解释）</p>
<h5 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h5><p>指的是具有多少个unit，一个bit是一个unit，那么bit数就是Memory的大小</p>
<h5 id="Addressability"><a href="#Addressability" class="headerlink" title="Addressability"></a>Addressability</h5><p>如果我们处理器是按照字节来处理的，一字节是8个bit，所以8就是Addressability</p>
<h5 id="Address-Space"><a href="#Address-Space" class="headerlink" title="Address Space"></a>Address Space</h5><p>这个指的是我们的内存有多少个字节，比如我们的内存是2MB，Address Space就是2 000 000（Bytes）</p>
<font color=red>所以我们发现 Memory = Addressability * Address Space</font>

<h5 id="RAM（Random-Access-Memory）"><a href="#RAM（Random-Access-Memory）" class="headerlink" title="RAM（Random Access Memory）"></a>RAM（Random Access Memory）</h5><p>RAM是 <strong>随机存取存储器</strong> （random access memory），是计算机 内部存储器 中的一种，也是其中最重要的，计算机和手机中一般把其叫做 （运行）内存 ，它的速度要比硬盘快得多，所以用运行程序在RAM中，而存放运行时不用的数据则在硬盘中，什么时候需要数据，便把数据从硬盘中拿到内存，但同时RAM断电会丢失数据，所以我们电脑如果断电了就会丢失原来正在运行的数据。RAM即内存越大，能同时在内存中执行的程序就越多，性能一般是越好的。</p>
<h6 id="Static-RAM（SRAM）"><a href="#Static-RAM（SRAM）" class="headerlink" title="Static RAM（SRAM）"></a>Static RAM（SRAM）</h6><p>可以认为是一个锁存器结构。速度快，只要不断电，数据一直都在，但是集成度低，生产成本高，所以一般用来制作容量小的高速缓冲存储器。</p>
<h6 id="Dynamic-RAM（DRAM）"><a href="#Dynamic-RAM（DRAM）" class="headerlink" title="Dynamic RAM（DRAM）"></a>Dynamic RAM（DRAM）</h6><p>用电容来存储数据。比较慢，且数据会随着电荷的衰退而丢失，所以需要定时更新。集成度高，生产成本低，所以一般用来制作容量大的主存储器。</p>
<font color=red>区别于Register和ROM，他们的容量和速度都是不一样的。（Register -> SRAM -> DRAM -> ROM 速度变小，容量变大）</font>

<h4 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h4><p>状态（state）：可以认为一次对这一瞬间的记录 —— 快照（snapshot）</p>
<p>状态机内部涉及到状态之间的转移，可以用状态图（state diagram）来表示</p>
<p>时序逻辑电路和组合逻辑电路更像是一种包含关系，时序包含组合，不同的是，时序中还有一些存储单元，存下的是上一状态，这将参与到下一次状态的计算中（在时序电路中完成）</p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h5yevrzqlpj312o0r1nan.jpg" alt="image"></p>
<p>时钟周期（Clock）通常认为是上升沿开始，经历一段1，然后是下降沿，然后是一段0</p>
<p>（这里助教曾说关于时钟周期可以自定义哪一段的说法，我觉得是对的，但是在理解课本内容方面没有任何帮助，所以建议是就把默认的时钟周期认为是前面写的那个版本）</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h5yew7fmpaj30wa06ojs5.jpg" alt="image"></p>
<h2 id="Chapter-4-The-Von-Neumann-Model"><a href="#Chapter-4-The-Von-Neumann-Model" class="headerlink" title="Chapter 4 The Von Neumann Model"></a>Chapter 4 The Von Neumann Model</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>五大部分：输入（INPUT）、输出（OUTPUT）、存储器（MEMORY）、处理器（PROCESSING UNIT）、控制器（CONTROL UNIT）</p>
<p><img src="https://tva4.sinaimg.cn/large/008cRf41ly1h5z6gj12xwj30zv0p47bw.jpg" alt="image"></p>
<h4 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h4><p>MAR：memory address register</p>
<p>MDR：memory data register</p>
<p>通过这两个寄存器，可以与内存进行交互（MAR存下地址值 MDR存下地址值对应的内容）</p>
<p><b>作用：存放信息</b></p>
<h4 id="PROCESSING-UNIT"><a href="#PROCESSING-UNIT" class="headerlink" title="PROCESSING UNIT"></a>PROCESSING UNIT</h4><p>ALU：arithmetic and logic unit算术与逻辑单元</p>
<p>Register：暂存数据的地方</p>
<p>Word Size：与Addressability大小一样</p>
<p><b>作用：对输入进行一些算术处理，然后把结果输出</b></p>
<h4 id="CONTROL-UNIT"><a href="#CONTROL-UNIT" class="headerlink" title="CONTROL UNIT"></a>CONTROL UNIT</h4><p>IR：Instruction Register指令寄存器存下当前处理的指令</p>
<p>PC：Program Counter包含着下一条指令的地址</p>
<p><b>作用：从内存中读取指令，然后解析后产生对应的信号让别的组成部分去执行</b></p>
<h4 id="INPUT-and-OUTPUT"><a href="#INPUT-and-OUTPUT" class="headerlink" title="INPUT and OUTPUT"></a>INPUT and OUTPUT</h4><p>LC-3支持键盘作为输入，显示器作为输出</p>
<p>所以对应的就有四个寄存器</p>
<p>KBDR：keyboard data register       KBSR：keyboard status register</p>
<p>DDR：display data register             DSR：display status register</p>
<p><b>作用：实现外界与计算机的交互</b></p>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h5z81js1sqj30dq083tb4.jpg" alt="image"></h3><h3 id="指令循环-Instruction-Cycle"><a href="#指令循环-Instruction-Cycle" class="headerlink" title="指令循环 Instruction Cycle"></a>指令循环 Instruction Cycle</h3><p><b>FETCH - DECODE - EVALUATE ADDRESS - FETCH OPERANDS - EXECUTE - STORE RESULT</b></p>
<p>总共是六个阶段，每个阶段都有具体的流程，每个阶段可能会花费一个或多个machine cycle（时钟周期）</p>
<font color=red>注：不同的指令可能需要不同的阶段，并非每一个阶段都必须做</font>

<h4 id="FETCH"><a href="#FETCH" class="headerlink" title="FETCH"></a>FETCH</h4><p>总共有四步</p>
<p><strong>MAR &lt;- PC :</strong> First the MAR is loaded with the contents of the PC. </p>
<p><strong>MDR &lt;- M[MAR] :</strong> Next, the memory is interrogated, which results in the next instruction being placed by the memory into the MDR. </p>
<p><strong>IR &lt;- MDR :</strong> Finally, the IR is loaded with the contents of the MDR.</p>
<p><strong>PC &lt;- PC + 1</strong></p>
<h4 id="DECODE"><a href="#DECODE" class="headerlink" title="DECODE"></a>DECODE</h4><p>这里就利用到了我们第三章谈到的译码器（DECODER），根据指令前四位（IR[15:12]）的内容，来判断通向哪一个处理路径</p>
<p>然后把后面的几位切割开，划分好哪些位是立即数，要用到哪些寄存器</p>
<h4 id="EVALUATE-ADDRESS"><a href="#EVALUATE-ADDRESS" class="headerlink" title="EVALUATE ADDRESS"></a>EVALUATE ADDRESS</h4><p>这个阶段主要干两件事，首先是Sign-extension，然后是与其他值进行一些运算</p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h5zay952n3j30o207dt9y.jpg" alt="image" style="zoom:80%;" /></p>
<h4 id="FETCH-OPERANDS"><a href="#FETCH-OPERANDS" class="headerlink" title="FETCH OPERANDS"></a>FETCH OPERANDS</h4><p>准备好要用的数据，这里的操作数可能是寄存器，也可能是MDR，或者是立即数</p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h5zb2im5wnj30mh06775c.jpg" alt="image" style="zoom: 80%;" /></p>
<h4 id="EXECUTE"><a href="#EXECUTE" class="headerlink" title="EXECUTE"></a>EXECUTE</h4><p>执行阶段</p>
<p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h5zb1xj464j30ra0610u2.jpg" alt="image" style="zoom:67%;" /></p>
<font color=red>值得注意的是ADD指令的EVALUATE ADDRESS， EXECUTE和 STORE RESULT三者同时可以放在一个clock内（其它很多计算机也是一样）具体的细节需要再学习更加深后才能明白</font>

<h4 id="STORE-RESULT"><a href="#STORE-RESULT" class="headerlink" title="STORE RESULT"></a>STORE RESULT</h4><p>把运算好的结果存放在指定地址或者是寄存器中</p>
<p><img src="https://tvax2.sinaimg.cn/large/008cRf41ly1h5zb1lim0yj30vt0adn0s.jpg" alt="image" style="zoom:67%;" /></p>
<h3 id="指令类型"><a href="#指令类型" class="headerlink" title="指令类型"></a>指令类型</h3><p>总共有Operates , Data movement , Control三种类型</p>
<h4 id="Operates"><a href="#Operates" class="headerlink" title="Operates"></a>Operates</h4><p>总共有三个：<em>ADD AND NOT</em></p>
<p>主要是在ALU里面进行一些运算，然后存储在指定寄存器内</p>
<p><b>LEA指令的分类比较茫，没有像data movement那样涉及到内存，但是它又和前面三个Operates有所区别</b></p>
<h4 id="Data-movement"><a href="#Data-movement" class="headerlink" title="Data movement"></a>Data movement</h4><p>总共有六个：<em>LDI LDR LD STI STR ST</em></p>
<p>主要是通过不同的方式存取地址里的内容</p>
<h4 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h4><p>剩下的全都是Control指令，<em>BR  JMP(RET)  JSR(JSRR) RTI TRAP</em>等</p>
<p>通常情况下，指令会一条一条的顺次执行到结束，但是这样的方式给我们带来一些不便（比如重复使用相同的指令，占用很多内存地址）</p>
<p>所以我们可以通过修改PC的值，改变程序的控制流，以达到一些循环结构</p>
<p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h5zg2nakl9j30s9041grs.jpg" alt="image" style="zoom: 67%;" /></p>
<p><b>TRAP指令</b></p>
<p>它也属于Control指令，但是又稍有不同，因为它涉及到特权模式的转化，TRAP指令中有一个八位的TRAP Vector，可以跳转到对应的位置上执行操作系统的程序，比如我们执行TRAP x25就可停机</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h5zgd7slq9j30zp0iznia.jpg" alt="image"></p>
<h2 id="Chapter-5-The-LC-3"><a href="#Chapter-5-The-LC-3" class="headerlink" title="Chapter 5 The LC-3"></a>Chapter 5 The LC-3</h2><h3 id="ISA-指令集架构（Instruction-Set-Architecture）"><a href="#ISA-指令集架构（Instruction-Set-Architecture）" class="headerlink" title="ISA 指令集架构（Instruction Set Architecture）"></a>ISA 指令集架构（Instruction Set Architecture）</h3><p>一个ISA主要包括<b>三个部分</b></p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h5zglqucfzj30uz0dg0y3.jpg" alt="image"></p>
<p>对于LC-3来说</p>
<p>①address space是2^16 locations    addressability是16bits</p>
<p>②registers包括了8个通用寄存器（general-purpose registers ）和别的一些特殊寄存器，比如PC，CC（conditional codes）</p>
<p>③Instrucion set部分：opcodes共有16个，有一个暂时没有被使用。data types主要是二补数。取址模式有三种：相对于PC的（PC-relative），间接取址（indirect），基偏移（base+offset）</p>
<h3 id="Operate-Instructions"><a href="#Operate-Instructions" class="headerlink" title="Operate Instructions"></a>Operate Instructions</h3><p>总共就三个 ADD AND NOT</p>
<h4 id="ADD-amp-AND"><a href="#ADD-amp-AND" class="headerlink" title="ADD &amp; AND"></a>ADD &amp; AND</h4><p>对于AND 和 ADD来说，二者十分相近（都有两种模式，是由IR[5]决定的）</p>
<p><img src="https://tvax4.sinaimg.cn/large/008cRf41ly1h5zgwtep0pj30zr0qewnh.jpg" alt="image" style="zoom:50%;" /></p>
<p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h5zh5ghotsj31030qrgvw.jpg" alt="image" style="zoom:50%;" /></p>
<h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h4><p>NOT指令，相对简单，就只有一个src，dst可以与src相同，也可以不同</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h5zh5ser2kj30ys0qb44k.jpg" alt="image" style="zoom:50%;" /></p>
<h3 id="Data-Movement-Instructions"><a href="#Data-Movement-Instructions" class="headerlink" title="Data Movement Instructions"></a>Data Movement Instructions</h3><h4 id="Load类和Store类"><a href="#Load类和Store类" class="headerlink" title="Load类和Store类"></a>Load类和Store类</h4><p>LD ST：PC-relative mode</p>
<p>LDR STR：base+offset mode</p>
<p>LDI STI：indirect mode</p>
<p>三种Load指令，都是将对应位置的内容存放在指定寄存器中，三种Store指令则正好相反</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h5zh6evz8wj30z50qh0zz.jpg" alt="image" style="zoom:50%;" /></p>
<p><img src="https://tvax4.sinaimg.cn/large/008cRf41ly1h5zh2nzuqyj30z50q5jyt.jpg" alt="image" style="zoom:50%;" /></p>
<p><img src="https://tvax4.sinaimg.cn/large/008cRf41ly1h602t379nej30z70qek04.jpg" alt="image" style="zoom:50%;" /></p>
<p><img src="https://tva4.sinaimg.cn/large/008cRf41ly1h602tv0bebj30zj0qbah9.jpg" alt="image" style="zoom:50%;" /></p>
<p><img src="https://tvax2.sinaimg.cn/large/008cRf41ly1h602ut69yhj30z70qh7bb.jpg" alt="image" style="zoom:50%;" /></p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h602v59juwj30yo0qdwlj.jpg" alt="image" style="zoom:50%;" /></p>
<h4 id="LEA（Leave-Effective-Address）"><a href="#LEA（Leave-Effective-Address）" class="headerlink" title="LEA（Leave Effective Address）"></a>LEA（Leave Effective Address）</h4><p>LEA是一个分类不明的指令，像是属于PC-relative，但是又不涉及内存，它只是把PC + offset的值放在指定寄存器中</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h6g8pd940wj30pt0hngoy.jpg" alt="image" style="zoom: 67%;" /></p>
<h3 id="Control-Instructions"><a href="#Control-Instructions" class="headerlink" title="Control Instructions"></a>Control Instructions</h3><p><b>Conditional Codes</b></p>
<p>这个存放在PSR[2:0]，PSR是processing status register，用于控制权限的一个寄存器，具体在后面会谈到。</p>
<p>当六个指令（ADD AND NOT LD LDR LDI）被执行时，执行阶段的最后会设置CC的值，CC包括了nzp三部分</p>
<p>分别是negative，zero和positive，然后被设置过的CC可以用于BR指令，进行一些条件跳转。</p>
<h4 id="条件跳转-Conditional-Branch"><a href="#条件跳转-Conditional-Branch" class="headerlink" title="条件跳转 Conditional Branch"></a>条件跳转 Conditional Branch</h4><p>这里主要就是一个BR指令，根据当前CC的值和BR指令内的条件，判断是否跳转到一个PC-relative的位置上继续执行程序。</p>
<p>如果满足条件，那么程序控制流发生改变，如果不满足条件，则程序继续向下执行。</p>
<font color=red>注：设置PCoffset9时易错，因为现在PC已经存放的是下一条指令了</font>

<font color=green>注：另外，PC+offset的计算不是在ALU内进行的，而是在一个特殊的加法器中（细节略过）</font>

<p><img src="https://tvax1.sinaimg.cn/large/008cRf41ly1h603f3rxv7j30xt0mvjy3.jpg" alt="image" style="zoom:50%;" /></p>
<h4 id="无条件跳转-Unconditional-Branch"><a href="#无条件跳转-Unconditional-Branch" class="headerlink" title="无条件跳转 Unconditional Branch"></a>无条件跳转 Unconditional Branch</h4><p>这里主要是JMP指令（当然还有JSR等，但是JMP是最基础的）</p>
<p>JMP指令是直接无脑跳转到指定位置</p>
<p><img src="https://tva3.sinaimg.cn/large/008cRf41ly1h603kuu26xj30xe0md453.jpg" alt="image" style="zoom:50%;" /></p>
<p>JSR JSRR</p>
<p>JSR（JSRR）使用的opcode是一样的，唯一的区别是第11位区分开了二者，JSR是PCoffset，JSRR是Base + 0（offset）</p>
<p>当修改完PC后，这两个指令会自动把R7的内容存放成原来PC的值（即JSR或JSRR的下一条指令）</p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h603pt3poyj30or07a0uu.jpg" alt="image" style="zoom:50%;" /></p>
<p>RET指令是用于从JSR或JSRR跳转出去后，调回来时使用的，它和JMP指令的opcode是一样的，唯一不同的是RET的Base必须是R7（因为我们之前已经把要跳回去的位置存放在了R7中）</p>
<p><img src="https://tva3.sinaimg.cn/large/008cRf41ly1h603tyw3c0j30on079wgm.jpg" alt="image" style="zoom:50%;" /></p>
<p>最后还有一个RTI（return from interrupt）</p>
<p>这条指令做的事情还蛮多的，这个我们在后面讲到中断时再详细展开</p>
<h4 id="TRAP"><a href="#TRAP" class="headerlink" title="TRAP"></a>TRAP</h4><p>TRAP指令的作用是跳转到OS中，执行对应片段的程序。这里要注意的是使用TRAP而不是自己直接跳转过去的原因是，TRAP指令执行时，会对用户的特权模式进行修改，以便我们可以正常执行，如果我们直接跳转过去，将会触发ACV（Access control violation）</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h603wkbh6mj310m0n0gud.jpg" alt="image" style="zoom:50%;" /></p>
<p>通过控制trapvector的值，我们就可以控制执行哪个TRAP程序</p>
<p>目前LC-3总共就6个TRAP程序，以下为对应的介绍</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h6g8pykl28j31300k67qd.jpg" alt="image" style="zoom: 50%;" /></p>
<h3 id="循环结构-loop-control"><a href="#循环结构-loop-control" class="headerlink" title="循环结构 loop control"></a>循环结构 loop control</h3><p>书上讲了两种方法：一种是通过设置一个Counter为指定值，每次循环给它减去一个1，判断计算的结果是否为0，若为0则跳出循环，这种方法就是计数法（Counter），还有一种是通过提前设置一个值为哨兵，我们每次循环都把某一个值进行一些变化，然后与哨兵进行运算，如果结果符合要求，我们就跳出循环，这叫做哨兵法（Sentinel）。</p>
<h2 id="Chapter-6-Programming"><a href="#Chapter-6-Programming" class="headerlink" title="Chapter 6 Programming"></a>Chapter 6 Programming</h2><h3 id="问题解决-Problem-Solving"><a href="#问题解决-Problem-Solving" class="headerlink" title="问题解决 Problem Solving"></a>问题解决 Problem Solving</h3><p>首先是对问题进行系统化拆解（systematic decomposition），系统化拆解包括搞清楚自然语言描述的问题，把问题转化为算法（转化为一步步的流程，具有那三大特性definiteness, effective computabiblity, finiteness），最后就可以按照流程进行结构化编程（structured programming）。</p>
<p>我们常见的三种结构是：顺序结构（sequential）条件结构（conditional）循环结构（iterative）</p>
<h3 id="调试-debugging"><a href="#调试-debugging" class="headerlink" title="调试 debugging"></a>调试 debugging</h3><p>bug：虫子，程序的错误所在</p>
<p>所谓debugging，也就是当我们运行程序发现不能正常运行时，我们要去做的调整工作，而哪里出了问题呢，这是调试中最难的一部分，所以我们要运用一定的调试技巧，节约我们找到错误的时间。</p>
<p>首先我们要把程序分块，切割成一个个独立的模块（modules），然后就可以用下面三种技巧</p>
<p><b>赋值法（set value）：在程序运行到当前模块时，我们手动修改所用到的变量的值，然后看这个模块的运行结果是否符合预期</b></p>
<p><b>执行序列（execute sequences）：设置断点（set breakpoint）+ 开始调试（run）+ 下一步（step）</b></p>
<p><b>显示值（display values）：在程序中段可以增加一些语句来输出中间变量，看哪一个模块出了问题</b></p>
<h2 id="Chapter-7-Assembly-Language"><a href="#Chapter-7-Assembly-Language" class="headerlink" title="Chapter 7 Assembly Language"></a>Chapter 7 Assembly Language</h2><p>为提高我们的编程效率，汇编语言就产生了，它对用户更加友好（user-friendly），更便于使用。</p>
<p>在汇编语言中，我们会有<b>符号化地址</b>（symbolic addresses），它可以独一无二的标记一些运算符和数据块、函数的位置，比如ADD NOT save1等等，这都是可以直接拿来使用的，然后我们也就不必去关心各种各样的偏移量和opcode等，提高了编程效率。</p>
<h3 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h3><h4 id="Opcode-and-Operands"><a href="#Opcode-and-Operands" class="headerlink" title="Opcode and Operands"></a>Opcode and Operands</h4><p>这是一条汇编语句必备的部分，要注意的是，不同的Opcode所关联的Operands的个数可能是不一样的，所以我们要相应地适配它所要求的个数，否则就会报错。</p>
<h4 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h4><p>标签是我们编程中极为重要的东西，因为我们在跳转时，我们如果想要直接找到函数入口或者是数据块的位置，那标签就可以极大的省去我们计算偏移量的时间。要注意的是Opcode（比如ADD NOT等）和其它有含义的字符串有一个合称：<strong>Reserved words</strong>，这些是不可以作为Label的，因为计算机不容许二义性（ambiguity）。</p>
<h4 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h4><p>LC-3的注释以；（semicolon）开始，后面可以跟上一些注释，便于调试和维护。</p>
<h4 id="伪指令-Pseudo-Ops"><a href="#伪指令-Pseudo-Ops" class="headerlink" title="伪指令 Pseudo-Ops"></a>伪指令 Pseudo-Ops</h4><h5 id="ORIG"><a href="#ORIG" class="headerlink" title=".ORIG"></a>.ORIG</h5><p>表明程序的开头</p>
<h5 id="FILL"><a href="#FILL" class="headerlink" title=".FILL"></a>.FILL</h5><p>表明在此处填充上给定内容</p>
<h5 id="BLKW"><a href="#BLKW" class="headerlink" title=".BLKW"></a>.BLKW</h5><p>开辟一块空间，方便后续使用</p>
<h5 id="STRINGZ"><a href="#STRINGZ" class="headerlink" title=".STRINGZ"></a>.STRINGZ</h5><p>在此处开始的内存上填充给定字符串（顺次填入每个 memory location）</p>
<h5 id="END"><a href="#END" class="headerlink" title=".END"></a>.END</h5><p>表明程序内容的结束，而非程序的结束，程序的结束需要用TRAP指令</p>
<h3 id="汇编过程-Assembly-Process"><a href="#汇编过程-Assembly-Process" class="headerlink" title="汇编过程 Assembly Process"></a>汇编过程 Assembly Process</h3><p><b>Two-Pass Process</b></p>
<p>对LC-3来说，采用的汇编过程是跑两次程序，有的汇编语言是跑一次的，这对应着不同的算法和机制。</p>
<p><b>第一次</b>:从头到尾跑，记录好每一条指令对应的地址值（通过一个变量LC即location counter逐个递增来完成），遇到Label就记录在一个表格中（<strong>symbol table</strong>），作用是便于第二次遍历时填入相应的内存值（或者偏移量）</p>
<p><strong>第二次</strong>:从头到尾跑，遇到Label就进行解释，通过symbol table内的值完成。</p>
<h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><h4 id="可执行文件-Executable-Image"><a href="#可执行文件-Executable-Image" class="headerlink" title="可执行文件 Executable Image"></a>可执行文件 Executable Image</h4><p>当我们汇编产生.o文件后，可能还会有别的.o文件与与之相关联，这个过程就叫做链接（<strong>link</strong>），生成可执行文件</p>
<h4 id="多于一个目标文件-More-than-One-Object-File"><a href="#多于一个目标文件-More-than-One-Object-File" class="headerlink" title="多于一个目标文件 More than One Object File"></a>多于一个目标文件 More than One Object File</h4><p>通常我们见到的真实的应用都是这样的情况，我们需要用一个外部声明 .External</p>
<p><img src="https://tvax2.sinaimg.cn/large/008cRf41ly1h62rp3lsluj30bg021wem.jpg" alt="image"></p>
<p><img src="https://tvax2.sinaimg.cn/large/008cRf41ly1h62rpkw775j30bj01lt8x.jpg" alt="image"></p>
<p>这样汇编器就不会报错说找不到STARTofFILE这个标签，而是会做一个标记，说这个标签存在于别的目标文件，在链接器链接时，它们之间的联系就会真实地建立起来。</p>
<h2 id="Chapter-8-Data-Structures"><a href="#Chapter-8-Data-Structures" class="headerlink" title="Chapter 8 Data Structures"></a>Chapter 8 Data Structures</h2><p>又名：<em>abstract data types</em></p>
<h3 id="子函数-Subroutines-Funtions"><a href="#子函数-Subroutines-Funtions" class="headerlink" title="子函数 Subroutines / Funtions"></a>子函数 Subroutines / Funtions</h3><p>通常我们写复杂程序时，有很多部分是会重复利用的，所以如果我们按照顺次排列的方式来写，可能会导致代码的可读性下降，所以我们可以使用子函数来简化我们的程序，让我们的程序主干更加清晰，可读性更强。另外，可能会有一些情况是不同的工程师写不同段的代码（当工程量巨大无比时），一个工程师写下这个函数，另一个工程师来调用它，这种情况也十分常见。</p>
<p><b>库（library）</b>：库的含义其实就是把许多子函数给封装起来，便于不同程序员进行调用。这样可以省去大家写一些重复性的代码，而且通常情况下，库的代码效率更高，调用起来也十分方便好用。</p>
<h4 id="调用和返回机制Call-Return-mechanism"><a href="#调用和返回机制Call-Return-mechanism" class="headerlink" title="调用和返回机制Call / Return mechanism"></a>调用和返回机制Call / Return mechanism</h4><p>主要就是JSR(R)和RET两条指令，唯一需要注意的是JSR除了修改程序的控制流，还会自动存下函数的返回地址（即跳转指令的下一条指令）于Ｒ７中，当ＲＥＴ指令执行时，Ｒ７的值就写入了ＰＣ中，开始接下来的程序。</p>
<p><b>寄存器可能不够用？</b></p>
<p>我们可以在内存中开辟一段空间，然后函数开始执行前，把一些包含关键内容的寄存器的值存在指定内存内，然后函数执行结束返回前把对应内存内的值再填回到寄存器中。</p>
<p>要注意有两种类型的暂存<strong>Caller Save</strong> 和 <strong>Callee Save</strong>，前者是调用者（源程序）做存储和恢复工作，而后者是被调用者做这样的工作。</p>
<font color=red>注意：书上的栈的Push（Pop与之相反）和队列的Remove和Insert都是先对指针操作，再去做别的操作。</font>



<h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><p>栈的特性是——<b>后进先出</b>:Last In，First Out，简称：LIFO</p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h62swqm0n1j30r60d1dkz.jpg" alt="image"></p>
<p>栈在内存上实现时，其实并没有“真正”弹出顶部元素，而是用一个栈指针（<strong>stack pointer</strong>），来控制当前栈顶元素的位置。当一个元素从栈中弹出时，其实在内存内还会暂存一段时间，不会立即被清除掉。</p>
<p><strong><em>stack protocal</em></strong>:当我们从栈中弹出元素后，不能再去访问被弹出的值所在的地址，尽管它可能还在内存上，这是约定俗成的规则。</p>
<p><strong><em>Underflow &amp; Overflow</em></strong>：通常我们会提前设置好栈的大小和栈的起始位置（默认用户模式下的起始位置是FDFF or FE00，也可以是别的位置，这取决于实现方式），那么当我们弹数据到边界时或者压入数据到边界时，我们就得特别注意，因为如果超出去，那程序段的内容可能会被修改，这将导致不可预想的后果。</p>
<h3 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归 Recursion"></a>递归 Recursion</h3><p>当我们执行一些特别的子函数时，我们可能需要调用子函数本身，那么它就意味着我们要去存下以及恢复过程变量以及返回地址（这部分语句将占用许多地址，但是确实是保证正确性所必要的），而且我们不可以把它们存放在固定的一个位置上，因为会相互覆盖，所以常见的方式是使用栈来存储，这也是当调用子函数过多，程序会炸的原因（栈溢出）。</p>
<p>当我们学会用递归来写阶乘和斐波那契后，我们会发现其实它可以改写成一个循环，而不需要重复调用函数，占用大量内存。这种递归叫做<strong>尾递归</strong>（递归返回时不需要做其它操作，或者说调用语句在递归函数的最后），其实尾递归可以算作是一种技巧，因为它可以大大提高程序运行效率（其实我们的编译器通常都会对尾递归进行优化），这算是一种技巧，但是本书中只是简单的提到了一下。</p>
<p>比如迷宫问题就不太适合用尾递归来解决，因为其中涉及到很多的判断和特殊处理，那么正常的递归就可以把问题清晰的表述并解决（虽然时间效率堪忧，但是是唯一选择）</p>
<h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h3><p>队列的特性——<b>先进先出 </b>：First In First Out，简称FIFO</p>
<p>由于它跟队列十分相近，只是由栈指针变成了一个头指针（<strong>FRONT</strong>）和尾指针（<strong>REAR</strong>），所以这里不过多介绍。</p>
<p><strong>但是要注意的是</strong>，我们通常使用的队列都是用n个位置存n-1个内容，原因如果我们要存n个内容，那么我们从队列上来看，满队列和空队列的指针位置是一样的，所以我们很难去判断Underflow和Overflow，因此n个位置存n-1个内容就成了约定俗成的东西。</p>
<p>注意一些特殊的结构：比如循环队列（Wrap-Around Queue）和双向队列（deque）</p>
<h3 id="字符串-Character-Strings"><a href="#字符串-Character-Strings" class="headerlink" title="字符串 Character Strings"></a>字符串 Character Strings</h3><p>在LC-3中，从字符串的方向上来看，是从低地址存到高地址的，所以是大端序。而且所有的都是存在了16-bit的低8位bit（TRAP指令有一个可以支持低八位和高八位都写入的情况 ）</p>
<font color=red>注：最后一位会自动补上x0000</font>

<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h62u9z43k9j30q404l790.jpg" alt="image"></p>
<p><b>正常版本</b></p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h62ub8g07ij30q102cmz7.jpg" alt="image"></p>
<h2 id="Chapter-9-I-O"><a href="#Chapter-9-I-O" class="headerlink" title="Chapter 9 I/O"></a>Chapter 9 I/O</h2><p><b>首先补充一下LC-3的内存分布</b></p>
<font color=orange>system space</font>

<p>x0000 ~ x00FF TRAP相关(<b>TRAP的别称：system call</b>)</p>
<p>​            [ 这段的地址及其内容合称 Trap Vector Table]</p>
<p>x0100 ~ 01FF Interrupt / Exception相关</p>
<p>​            [ 从x0180分开，前半段是第一类（exception），后半段是第二类（interrupt） ]</p>
<p>x0200 ~ x2FFF 操作系统代码段</p>
<p>​            [ 最开头的一小段是开机相关的内容 ]</p>
<font color=orange>user space</font>

<p>x3000 ~ xFDFF User用户段</p>
<font color=orange>I/O Page</font>

<p>xFE00 ~ I / O相关代码段和特殊寄存器</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Privilege-amp-Priority"><a href="#Privilege-amp-Priority" class="headerlink" title="Privilege &amp; Priority"></a>Privilege &amp; Priority</h4><p>二者有所区别，且与我们生活的常规，因为我们生活中自然而然地认为二者甚至是近义词，但在计算机中会不同。</p>
<p>Privilege表明权力，等级，更多的是每一种事物都具有的固定属性，不同的Privilege区别开不同权力的程序，低权力程序不能做高权力程序的事情。</p>
<p>Priority表明优先级，更像是动态的属性，比如我们正在做某件事情，可能会被更高优先级的事情给打断。类似地，一个程序在运行时，如果有更高优先级的程序打断（比如键盘输入），那么计算机会优先处理更高优先级的程序。</p>
<h4 id="PSR（Processor-Status-Register）xFFFC"><a href="#PSR（Processor-Status-Register）xFFFC" class="headerlink" title="PSR（Processor Status Register）xFFFC"></a>PSR（Processor Status Register）xFFFC</h4><p><b>注：MCR (Processor’s Master Control Register) xFFFE</b></p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h62xcoirllj30rn04btab.jpg" alt="image"></p>
<p>PSR[15]表明Privilege，如果为1表明User mode（Unprivileged），如果为0表明Supervisor mode（Privileged）</p>
<p>PSR[10:8]表明Priority，是一个介于0~7之间的值，二进制表示</p>
<p>PSR[2:0]表明conditional code，是一个动态刷新的码，有六条指令可以修改，BR指令会用来判断并分支。</p>
<h4 id="USP-amp-SSP"><a href="#USP-amp-SSP" class="headerlink" title="USP &amp; SSP"></a>USP &amp; SSP</h4><p>User Stack Pointer &amp; Supervisor Stack Pointer</p>
<p>要注意的是R6通常用来放正在使用的栈指针，而切换时要用到两个特殊寄存器Saved_USP或Saved_SSP来暂存不用的栈顶指针</p>
<h3 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input / Output"></a>Input / Output</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p><b>Memory-Mapped I/O &amp; Special I/O instructions</b></p>
<p>前者是大多数计算机采用的输入输出处理方式，后者是比较小众的方式，每一个设备都有自己的I/O处理指令（比如1965年的PDP-8） LC-3采用的是前者，内存映射型I/O。之所以叫这个名字，是因为要遵循普适性，原理是在ISA的内存地址上开辟一块空间专门用来存储与I/O相关的寄存器，比如LC-3的xFE00 ~ XFFFF就是这样，I/O设备的寄存器就可以与我们开辟的内存区域一一映射，所以我们称之为内存映射型I/O。</p>
<p><b>Asynchronous  &amp; Synchronous</b></p>
<p>同步和异步，提到这两个词是因为输入输出设备的处理速度是不同于CPU的处理速度的，我们称之为<strong>异步</strong>。那也就意味着让一个人一秒钟打3000000个字不可能实现，这个问题如果想解决：</p>
<p>首先我们能想到的是放慢速度，比如每秒输入3个字母，设置一定的间隔，让某些打字员（虽然很难有人做得到）按照这样的频率输入即可，同步化两个异步的设备，但是这个也太难了，有几个人能做到呢？</p>
<p>所以我们就可以引入一个<strong>标志</strong>（FLAG or Ready bit）来标识当前设备是否准备好了，程序运行到这一段CPU就去查询是否准备好了，如果准备好了那么就输入，如果没有，可能会直接抛弃输入的东西，或者会缓存下来（取决于不同的外设），然后这样就可以完成简单的同步化。（Polling方式）</p>
<p><b>Interrupt-Driven &amp; Polling</b></p>
<p>前者与后者的区别在于，前者是由键盘控制着交互过程，后者是由处理器控制着交互过程。</p>
<p><strong>Interrupt-Driven</strong>是在程序正常运行过程中，键盘的输入打断了原有程序，程序控制流跳转到键盘处，然后执行结束后交还控制流。</p>
<p><strong>Polling</strong>是程序运行到某一处后，就开始不断的询问当前KBSR是否已经被set（[15]设置为1），如果设置好了，那就表明键盘已经有输入了，如果没有设置好，那就说明现在还是处于clear状态（[15]为0），这时程序就会不断循环，直到有数据输入。</p>
<font color=red>下面将先用Polling的方式讲解Keyboard和Display，然后才是Interrupt-driven</font>

<h4 id="Input-From-The-Keyboard"><a href="#Input-From-The-Keyboard" class="headerlink" title="Input From The Keyboard"></a>Input From The Keyboard</h4><p>关键的两个寄存器： <strong>KBSR（xFE00） &amp; KBDR（xFE02）</strong></p>
<p><img src="https://tva4.sinaimg.cn/large/008cRf41ly1h63v1bvslmj30s30b9jxc.jpg" alt="image" style="zoom: 67%;" /></p>
<p>对计算机而言，分配16bit比分配特定数量的bit来的容易，所以上图中我们看到kBSR和KBDR中的bit只有部分得到了使用，而非全部。</p>
<p>KBDR是只有[7:0]被使用，KBSR是只有[15]被使用。</p>
<p><strong>处理机制</strong>：正常状态下KBSR的15位为0，表明现在键盘可以输入，这时如果键盘被敲击，那KBDR的低八位bit就会载入这个字符的ASCII，然后KBSR的15位自动置为1，表明现在读入的字符正在被程序读取，这时如果键盘继续被敲击，不会有新的字符载入KBDR，直到读取结束，KBSR的15位置为0，才会开始下一个字符的读入。</p>
<h4 id="Output-to-the-Monitor"><a href="#Output-to-the-Monitor" class="headerlink" title="Output to the Monitor"></a>Output to the Monitor</h4><p>关键的两个寄存器：<strong>DSR（xFE04） &amp; DDR（xFE06）</strong></p>
<p><img src="https://tva3.sinaimg.cn/large/008cRf41ly1h63vhxvyraj30rx0amjy3.jpg" alt="image" style="zoom:67%;" /></p>
<p><strong>处理机制</strong>：其实它们的处理机制与KBDR和KBSR是完全一致的。正常状态下DSR的15位为1，当我们想要展示的字符提供给设备后，DSR的15位会被clear为0，设备开始处理（此时仍处于clear状态），然后处理结束后DSR的15位就会被set成1，然后就开始运行接下来的程序，在DSR的15位为0的过程中，DDR只能处理一个值（一个锁定的状态），新的想要展示的字符不会载入到DDR中。</p>
<h3 id="操作系统服务程序：TRAP-Routines"><a href="#操作系统服务程序：TRAP-Routines" class="headerlink" title="操作系统服务程序：TRAP Routines"></a>操作系统服务程序：TRAP Routines</h3><p><b>为什么要这样设置?</b></p>
<p>两方面原因，一方面是，让所有的程序编写者去了解这些status register和data register是一件不容易的事情，因为难度比编写程序来得高，另一方面是，I/O设备是由所有用户共享的，如果把访问和修改的权利交给每一个用户，可能会导致别的用户也无法使用I/O设备了，这并不是我们期望的结果，所以我们通过设置privilege，让普通用户只能调用函数使用，而不是自己写程序来操作设备寄存器。</p>
<p><b>TRAP / system call / service call的流程</b>：通常情况下，我们运行到程序的一处，然后我们调用操作系统来帮我们执行一些程序（比如输入输出，停机等），这时操作系统会接管计算机，控制流也交给操作系统，操作系统全部弄完后，把控制流再交还给我们自己的程序。</p>
<h4 id="Trap-Vector-Table"><a href="#Trap-Vector-Table" class="headerlink" title="Trap Vector Table"></a>Trap Vector Table</h4><p><img src="https://tvax4.sinaimg.cn/large/008cRf41ly1h63xeqmof8j30cn0glmz9.jpg" alt="image" style="zoom:50%;" /></p>
<p>这里我们看到只有六个，其余的空间都填充着无意义的值x038C</p>
<p><img src="https://tvax2.sinaimg.cn/large/008cRf41ly1h63xje36xuj30n60j5wil.jpg" alt="image" style="zoom:50%;" /></p>
<p>我们在LC-3 tools中查看x038C的内容，其实跳转后，都报错 “BAD TRAP”</p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h63xi2dmz4j30ie035gly.jpg" alt="image"></p>
<p>也就是说，目前的LC-3指令虽然可以支持256条TRAP指令，但是目前就只有这六种是有意义的</p>
<center><b>GETC      OUT      PUTS     IN     PUTSP     HALT</b></center>

<h4 id="两条指令"><a href="#两条指令" class="headerlink" title="两条指令"></a>两条指令</h4><h5 id="TRAP-Instruction"><a href="#TRAP-Instruction" class="headerlink" title="TRAP Instruction"></a>TRAP Instruction</h5><p><img src="https://tva3.sinaimg.cn/large/008cRf41ly1h63xmqp9goj30pi03twg0.jpg" alt="image" style="zoom:67%;" /></p>
<p><strong>TRAP过程详解</strong>：首先，当前程序的PSR和PC都会被压到系统栈上（这里的PC要减去一个1保证返回时完美衔接），并且在压栈前，如果当前是用户模式，需要切换到超级模式（把当前的栈指针存到Saved_USP，把系统栈指针&lt;存储在Saved_SSP处&gt;复制给活跃指针——R6）；然后，PSR[15]被置为0，PSR[10:8]保持不变，因为TRAP指令的priority与原程序一致。接下来，8bit的trap vector会被扩展到16bit并放入MAR中，MDR对应的修改，PC会被写入MDR的内容（MAR地址处存放的东西）；最后，程序就开始执行系统段的代码了。</p>
<h5 id="RTI-Instruction"><a href="#RTI-Instruction" class="headerlink" title="RTI Instruction"></a>RTI Instruction</h5><p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h63xvzcqw3j30oy0390u4.jpg" alt="image" style="zoom:67%;" /></p>
<p>全称：<strong>R</strong>eturn from <strong>T</strong>rap or <strong>I</strong>nterrupt</p>
<p><strong>RTI过程详解</strong>：首先POP系统栈栈顶的两个元素，分别是PC和PSR，然后判断PSR[15]的值，如果是1，那就意味着现在要从超级模式跳回用户模式了，那么当前的栈指针要存下来（Saved_SSP），并且活跃指针R6要载入到原来用户栈的栈指针（之前存储在Saved_USP）。</p>
<h4 id="TRAP的各种程序"><a href="#TRAP的各种程序" class="headerlink" title="TRAP的各种程序"></a>TRAP的各种程序</h4><h5 id="Input-amp-Output"><a href="#Input-amp-Output" class="headerlink" title="Input &amp; Output"></a>Input &amp; Output</h5><p>都是用Polling实现的，这里就不多展开</p>
<h5 id="HALT"><a href="#HALT" class="headerlink" title="HALT"></a>HALT</h5><p>这里需要补充的是<strong>MCR</strong>（the processor‘s Master Control Register）</p>
<p>这个寄存器只有[15]是有意义的，因为Clock信号是由晶体振荡器（crystal oscillator）和RUN-Latch（即MCR）AND之后得到的，所以如果我们想要停机，只需要把[15]置为0即可，我们在TRAP HALT中使用一个bit vector叫做MASK：x7fff，与原来的MCR（正常运行时MCR的值为x4000）AND，然后结果存放到MCR中，这样程序就停下来了。</p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h63ykrursaj30wa0mjk01.jpg" alt="image" style="zoom:50%;" /></p>
<p>其实当红线处执行后，程序就停下来了，所以虽然后面黄线部分还有一些返回程序，但是它们是不会执行的。</p>
<font color=red>前面我们用Polling的方式讲解了输入输出的一种方法，下面我们从Interrupt-Driven来理解</font>

<h3 id="Interrupts-amp-Interrupt-Driven-I-O"><a href="#Interrupts-amp-Interrupt-Driven-I-O" class="headerlink" title="Interrupts &amp; Interrupt Driven I/O"></a>Interrupts &amp; Interrupt Driven I/O</h3><p>中断程序的优势就在于它把Polling不断询问的时间，拿来做别的事情了，时间效率高。每当有中断程序打断时，处理器就先跳转过去处理，等到处理结束后再跳转回来。</p>
<h4 id="触发中断详解"><a href="#触发中断详解" class="headerlink" title="触发中断详解"></a>触发中断详解</h4><h5 id="PART1——中断的前置条件"><a href="#PART1——中断的前置条件" class="headerlink" title="PART1——中断的前置条件"></a><font color=red size=5>PART1——中断的前置条件</font></h5><h6 id="IE-amp-PL"><a href="#IE-amp-PL" class="headerlink" title="IE &amp; PL"></a><strong>IE</strong> &amp; PL</h6><p>在KBSR和DSR中，[14]其实有别的含义，即<strong>IE（interrupt enable）</strong>，我们的中断信号（interrupt signal）来源于[15] AND [14]，所以在中断程序中，我们需要提前设置好IE（值为1）。另外，我们还需要保证的是把中断请求的<strong>PL（priority level）</strong>高于普通用户程序，这个通常是不需要修改的，因为每一种设备会有它自己的Priority。</p>
<p><b>补充：</b>在实际编程中我们在x200处（开机程序）除了要把IE设置好，还需要把Interrupt Vector Table设置好，也就是说，在一种设备对应的位置上填上我们自定义中断函数的首地址。（实验中我们使用的是x180处填上x2000——键盘中断函数的首地址）</p>
<h6 id="INT-Signal"><a href="#INT-Signal" class="headerlink" title="INT Signal"></a><b>INT Signal</b></h6><p>中断信号：如果前面PART1的事情全都满足了，中断信号就会被设定<strong>（asserted）</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h642g7fg9sj30sp0lljtx.jpg" alt="image" style="zoom:67%;" /></p>
<p><strong>Test for INT signal</strong>：中断信号的设定可以发生在任何时候，但是我们处理中断发生在FETCH阶段（一定程度上可以省下不少状态，因为我们不用去关心当前指令的哪些部分已经被执行了，哪些部分还没被执行）。</p>
<h5 id="PART2——中断的执行过程"><a href="#PART2——中断的执行过程" class="headerlink" title="PART2——中断的执行过程"></a><font color=red size=5>PART2——中断的执行过程</font></h5><p>总共分为三步</p>
<p><img src="https://tva4.sinaimg.cn/large/008cRf41gy1h6433ouemkj30nq03rwhx.jpg" alt="image"></p>
<h6 id="Step1-初始化中断"><a href="#Step1-初始化中断" class="headerlink" title="Step1 初始化中断"></a>Step1 初始化中断</h6><p>首先把PC和PSR进行一波压栈（压在系统栈上），在压栈之前检测是否已经切换活跃栈指针（active stack pointer），如果没有，那么要先切换一下，然后是修改PSR[15]为0和PSR[10:8]为中断请求的priority，关于PSR[2:0]书上说由于在超级模式下任何一条指令都还没有执行，我们赋初值为010，<strong>这一点要特别注意</strong>。然后是table&lt;- 01（区别于TRAP的00，含义是vector的起始位置），Vector就载入INTV（Interrupt Vector，提前设置好的），然后把二者拼起来就可以在Interrupt Vector Table内找到对应的位置跳转过去，执行中断程序。</p>
<h6 id="Step2-执行中断"><a href="#Step2-执行中断" class="headerlink" title="Step2 执行中断"></a>Step2 执行中断</h6><p>当我们把中断请求在Interrupt Vector Table内的值找到并复制到PC中时，中断就正式开始执行了，这时与用户模式下的指令执行没有什么区别。</p>
<h6 id="Step3-从中断返回"><a href="#Step3-从中断返回" class="headerlink" title="Step3 从中断返回"></a>Step3 从中断返回</h6><p>这与TRAP指令的RTI是完全一样的，毕竟RTI即Return from Trap or Interrupt</p>
<p><br></p>
<p><b>要注意的是，Interrupt不是只关于I/O的，它还可以有很多延展。下面是课本中举的三个例子</b></p>
<p><img src="https://tva2.sinaimg.cn/large/008cRf41ly1h645a3scrxj30sb07bgv3.jpg" alt="image"></p>
<h2 id="附录-A-amp-C"><a href="#附录-A-amp-C" class="headerlink" title="附录 A&amp;C"></a>附录 A&amp;C</h2><h3 id="附录A-：The-LC-3-ISA-Instructions"><a href="#附录A-：The-LC-3-ISA-Instructions" class="headerlink" title="附录A ：The LC-3 ISA Instructions"></a>附录A ：The LC-3 ISA Instructions</h3><h4 id="A-1-Overview"><a href="#A-1-Overview" class="headerlink" title="A.1 Overview"></a>A.1 Overview</h4><p>这部分主要对所有LC-3中用到的和图中出现的相对专业的名词做了解释</p>
<h4 id="A-2-The-Instruction-Set"><a href="#A-2-The-Instruction-Set" class="headerlink" title="A.2 The Instruction Set"></a>A.2 The Instruction Set</h4><p>这里对每条指令都做了详细的解释，包括二进制代码和汇编代码。</p>
<h4 id="A-3-Interrupt-and-Exception-Processing"><a href="#A-3-Interrupt-and-Exception-Processing" class="headerlink" title="A.3 Interrupt and Exception Processing"></a>A.3 Interrupt and Exception Processing</h4><p>前面所有提到的内容我们直接代过，部分内容补充如下</p>
<h5 id="对x0100-x01FF的划分（总称为Interrupt-Vector-Table）"><a href="#对x0100-x01FF的划分（总称为Interrupt-Vector-Table）" class="headerlink" title="对x0100 ~ x01FF的划分（总称为Interrupt Vector Table）"></a><strong>对x0100 ~ x01FF的划分（总称为Interrupt Vector Table）</strong></h5><p>①x0100 ~ x017F这部分是exception部分的代码段，这是由程序自己引起的。包括了三种情况：<strong>privilege mode violation（USER模式    下调用RTI）, illegal opcode（1101）, and access control violation (ACV).</strong>三者顺次对应的vector是x00 x01 x02</p>
<p>②x0180 ~ x01FF这部分是Interrupt的代码段，这是由设备打断引起的，可由用户自行设计。常见的是键盘，Priority Level是4，在Table里面对应的是x0180位置。</p>
<p>这里需要补充的是，具体的exception如何施行，这是因情况而异的，但可以肯定的是，结果通常是计算机自动修正错误，然后让程序恢复，继续运行下去。另外，exception在执行时，程序的priority是不发生改变的，即与原来的程序priority保持一致，这与Interrupt不同，因为中断程序的Priority必须高于原来程序的Priority。</p>
<h3 id="附录C-：The-Microarchitecture-of-the-LC-3"><a href="#附录C-：The-Microarchitecture-of-the-LC-3" class="headerlink" title="附录C ：The Microarchitecture of the LC-3"></a>附录C ：The Microarchitecture of the LC-3</h3><p><b>注：这里只是一个LC-3微架构的例子，和其它ISA一样，其对应的微架构可以有多种</b></p>
<h4 id="State-Machine-amp-Data-Path"><a href="#State-Machine-amp-Data-Path" class="headerlink" title="State Machine &amp; Data Path"></a>State Machine &amp; Data Path</h4><p><img src="https://tva4.sinaimg.cn/large/008cRf41ly1h67pu6ste9j30tq10snbw.jpg" alt="image"></p>
<p><img src="https://tva4.sinaimg.cn/large/008cRf41ly1h67puluio5j30ot0y17dc.jpg" alt="image"></p>
]]></content>
      <tags>
        <tag>Courses</tag>
      </tags>
  </entry>
  <entry>
    <title>贝塞尔曲线的实现</title>
    <url>/posts/5a60474d/</url>
    <content><![CDATA[<p>今天简单实现了一下贝塞尔曲线，用到了Eigen库，简单配置之后把普通实现法和de Casteljau法都实现了一下，总结在这篇博客里面<br><span id="more"></span></p>
<h1 id="贝塞尔曲线的实现"><a href="#贝塞尔曲线的实现" class="headerlink" title="贝塞尔曲线的实现"></a>贝塞尔曲线的实现</h1><h2 id="普通实现法"><a href="#普通实现法" class="headerlink" title="普通实现法"></a>普通实现法</h2><p>这里采用了三次贝塞尔曲线为例（因为更高次的M矩阵求起来比较麻烦）</p>
<p>这里略去具体的推导方法，其实利用了Hermite曲线的形式，唯一的区别就在于贝塞尔曲线头尾节点处由一个方向向量控制，而Hermite曲线有两个正切值来控制。</p>
<p>当u取0到1之间的值时，对应贝塞尔曲线上的点为</p>
<script type="math/tex; mode=display">
P(u)=U^TM_{H}B</script><p>上式中的U，MH，B分别为</p>
<script type="math/tex; mode=display">
U=[u^3,u^2,u,1]</script><script type="math/tex; mode=display">
M_{H}=\begin{bmatrix}
    -1&3&-3&1\\
    3&-6&3&0\\
    -3&3&0&0\\
    1&0&0&0
\end{bmatrix}</script><script type="math/tex; mode=display">
B=\begin{bmatrix}
    P_0\\
    P_1\\
    P_2\\
    P_3
\end{bmatrix}</script><p>所以我们代码实现为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Eigen\Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pos</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">&#125;Position[N];</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">640</span>, <span class="number">480</span>);</span><br><span class="line">	<span class="built_in">setbkcolor</span>(WHITE);</span><br><span class="line">	<span class="built_in">cleardevice</span>();</span><br><span class="line">	<span class="built_in">setcolor</span>(BLACK);</span><br><span class="line">	<span class="type">char</span> out[] = <span class="string">&quot;鼠标左键顺次设定四个Bezier Point，选择完成后自动绘制Bezier曲线&quot;</span>;</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">80</span>, <span class="number">20</span>, out);</span><br><span class="line">	ExMessage mes;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">		mes = <span class="built_in">getmessage</span>(EX_MOUSE | EX_KEY);</span><br><span class="line">		<span class="keyword">switch</span>(mes.message)&#123;</span><br><span class="line">			<span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">				Position[t].x = mes.x;</span><br><span class="line">				Position[t].y = mes.y;</span><br><span class="line">				<span class="built_in">setfillcolor</span>(BLACK);</span><br><span class="line">				<span class="built_in">solidcircle</span>(mes.x, mes.y, <span class="number">1</span>);</span><br><span class="line">				++t;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Vector4f Px, Py;</span><br><span class="line">	Px &lt;&lt; Position[<span class="number">0</span>].x, Position[<span class="number">1</span>].x, Position[<span class="number">2</span>].x, Position[<span class="number">3</span>].x;</span><br><span class="line">	Py &lt;&lt; Position[<span class="number">0</span>].y, Position[<span class="number">1</span>].y, Position[<span class="number">2</span>].y, Position[<span class="number">3</span>].y;</span><br><span class="line">	Matrix4f M;</span><br><span class="line">	M &lt;&lt; <span class="number">-1</span>, <span class="number">3</span>, <span class="number">-3</span>, <span class="number">1</span>,</span><br><span class="line">		<span class="number">3</span>, <span class="number">-6</span>, <span class="number">3</span>, <span class="number">0</span>,</span><br><span class="line">		<span class="number">-3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">		<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">double</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i += <span class="number">1e-3</span>) &#123;</span><br><span class="line">		Vector4f U;</span><br><span class="line">		U &lt;&lt; i * i * i, i* i, i, <span class="number">1</span>;</span><br><span class="line">		<span class="type">double</span> temp_x = U.<span class="built_in">transpose</span>() * M * Px;</span><br><span class="line">		<span class="type">double</span> temp_y = U.<span class="built_in">transpose</span>() * M * Py;</span><br><span class="line">		<span class="built_in">solidcircle</span>(temp_x, temp_y, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">EndBatchDraw</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现效果为</p>
<p><img src="https://tva1.sinaimg.cn/large/008cRf41ly1h6us82jshej30qp0lbab5.jpg" alt="image" style="zoom:50%;" /></p>
<h2 id="de-Casteljau法"><a href="#de-Casteljau法" class="headerlink" title="de Casteljau法"></a>de Casteljau法</h2><p>利用多次线性插值替代普通实现法中的那种重复计算u^n, 还能减低数值误差</p>
<p>代码实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;graphics.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Eigen\Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000</span></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"><span class="function">Vector2f <span class="title">GetPos</span><span class="params">(Vector2f* last, <span class="type">double</span> u, <span class="type">int</span> ones)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ones == <span class="number">1</span>) <span class="keyword">return</span> last[<span class="number">0</span>];</span><br><span class="line">	Vector2f* temp = (Vector2f*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Vector2f) * t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ones - <span class="number">1</span>; ++i)</span><br><span class="line">		temp[i] = (<span class="number">1</span> - u) * last[i] + u * last[i + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">GetPos</span>(temp, u, ones - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Vector2f P[N];</span><br><span class="line">	<span class="built_in">initgraph</span>(<span class="number">640</span>, <span class="number">480</span>);</span><br><span class="line">	<span class="built_in">setbkcolor</span>(WHITE);</span><br><span class="line">	<span class="built_in">cleardevice</span>();</span><br><span class="line">	<span class="built_in">setcolor</span>(BLACK);</span><br><span class="line">	<span class="type">char</span> out[] = <span class="string">&quot;鼠标左键顺次设定Bezier Point，按下回车自动绘制Bezier曲线&quot;</span>;</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">80</span>, <span class="number">20</span>, out);</span><br><span class="line">	ExMessage mes;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		mes = <span class="built_in">getmessage</span>(EX_MOUSE | EX_KEY);</span><br><span class="line">		<span class="keyword">switch</span> (mes.message) &#123;</span><br><span class="line">		<span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">			P[t].<span class="built_in">x</span>() = mes.x;</span><br><span class="line">			P[t].<span class="built_in">y</span>() = mes.y;</span><br><span class="line">			<span class="built_in">setfillcolor</span>(BLACK);</span><br><span class="line">			<span class="built_in">solidcircle</span>(mes.x, mes.y, <span class="number">1</span>);</span><br><span class="line">			++t;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">			<span class="keyword">if</span> (mes.vkcode == VK_RETURN)</span><br><span class="line">				<span class="keyword">goto</span> done;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">done:</span><br><span class="line">	<span class="built_in">BeginBatchDraw</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">double</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i += <span class="number">1e-3</span>) &#123;</span><br><span class="line">		Vector2f po = <span class="built_in">GetPos</span>(P, i, t);</span><br><span class="line">		<span class="built_in">solidcircle</span>((<span class="type">int</span>)po.<span class="built_in">x</span>(), (<span class="type">int</span>)po.<span class="built_in">y</span>(), <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">EndBatchDraw</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现效果如下</p>
<p><img src="https://tvax3.sinaimg.cn/large/008cRf41ly1h6usf28g9bj30qr0lbdgz.jpg" alt="image" style="zoom:50%;" /></p>
]]></content>
      <tags>
        <tag>CG</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑运算符的性能优化（短路问题）</title>
    <url>/posts/40853/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="逻辑运算符的性能优化（短路问题）"><a href="#逻辑运算符的性能优化（短路问题）" class="headerlink" title="逻辑运算符的性能优化（短路问题）"></a>逻辑运算符的性能优化（短路问题）</h1><p><font color=orange>在Python中存在这样的规则<br>我们举个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">35</span></span><br><span class="line">a &gt; <span class="number">32</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&#x27;我被运行了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">输出结果：我被运行了</span><br><span class="line"></span><br><span class="line">a = <span class="number">35</span></span><br><span class="line">a &gt; <span class="number">38</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&#x27;我被运行了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">无输出结果</span><br><span class="line"></span><br><span class="line">a = <span class="number">35</span></span><br><span class="line">a &gt; <span class="number">32</span> <span class="keyword">or</span> <span class="built_in">print</span>(<span class="string">&#x27;我被运行了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">无输出结果</span><br><span class="line"></span><br><span class="line">a = <span class="number">35</span></span><br><span class="line">a &gt; <span class="number">38</span> <span class="keyword">or</span> <span class="built_in">print</span>(<span class="string">&#x27;我被运行了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">输出结果：我被运行了</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color=red><br>从上面的代码和它的输出结果来看，Python中存在这样的规则：<br><br>a and b 如果a为false，则b直接跳过<br><br>a or b 如果a为true，则b直接跳过<br></p>
<p><font color=green><br>其实，C语言中也有类似的规则，本质上是为了提高代码的性能。<br><br>希望这篇文章能给你带来帮助！</p>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度模板合集与优化</title>
    <url>/posts/40625/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h1 id="高精度模板合集与优化（无注释版）"><a href="#高精度模板合集与优化（无注释版）" class="headerlink" title="高精度模板合集与优化（无注释版）"></a>高精度模板合集与优化（无注释版）</h1><p>我把所有的高精度模板总结了一下，收录在这里，希望对大家有帮助。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>1.高精度加法<br>2.高精度减法<br>3.高精度乘法<br>4.高精度除法<br>（1）高精度除以低精度<br>（2）高精度除以高精度</strong><br><strong>5.高精度算法的优化思路</strong></p>
<h2 id="一、高精度加法"><a href="#一、高精度加法" class="headerlink" title="一、高精度加法"></a>一、高精度加法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000000</span></span><br><span class="line"><span class="type">int</span> t1[N], t2[N], c[N];</span><br><span class="line"><span class="type">char</span> a[N], b[N];<span class="comment">// 两个加数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt; a&gt;&gt; b;<span class="comment">//输入两个加数 </span></span><br><span class="line">	<span class="type">int</span> lena = <span class="built_in">strlen</span>(a);</span><br><span class="line">	<span class="type">int</span> lenb = <span class="built_in">strlen</span>(b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lena; ++ i) t1[lena - i] = a[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//存下两个加数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenb; ++ i) t2[lenb - i] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> len = lena &gt; lenb ? lena : lenb;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++ i)&#123;<span class="comment">//从低位到高位的处理 </span></span><br><span class="line">		c[i] += t1[i] + t2[i];</span><br><span class="line">		<span class="keyword">if</span>(c[i] &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">			c[i] %= <span class="number">10</span>;</span><br><span class="line">			c[i + <span class="number">1</span>] ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(c[len + <span class="number">1</span>]) len ++;<span class="comment">//最高位的判断 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、高精度减法"><a href="#二、高精度减法" class="headerlink" title="二、高精度减法"></a>二、高精度减法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000000</span></span><br><span class="line"><span class="type">int</span> t1[N], t2[N], c[N];</span><br><span class="line"><span class="type">char</span> a[N], b[N];<span class="comment">// 两个数</span></span><br><span class="line"><span class="type">char</span> ch[N];<span class="comment">//中间字符串</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt; a&gt;&gt; b;<span class="comment">//输入数 </span></span><br><span class="line">	<span class="type">int</span> lena = <span class="built_in">strlen</span>(a);</span><br><span class="line">	<span class="type">int</span> lenb = <span class="built_in">strlen</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(lena &lt; lenb || (lena == lenb &amp;&amp; <span class="built_in">strcmp</span>(a, b) &lt; <span class="number">0</span>))&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(ch, a);</span><br><span class="line">		<span class="built_in">strcpy</span>(a, b);</span><br><span class="line">		<span class="built_in">strcpy</span>(b, ch);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">	&#125;<span class="comment">//如果前一个数小于后一个数，则交换二者 </span></span><br><span class="line">	lena = <span class="built_in">strlen</span>(a); </span><br><span class="line">	lenb = <span class="built_in">strlen</span>(b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lena; ++ i) t1[lena - i] = a[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//存下两个数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenb; ++ i) t2[lenb - i] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> len = lena &gt; lenb ? lena : lenb;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++ i)&#123;<span class="comment">//从低位到高位的处理 </span></span><br><span class="line">		c[i] += t1[i] - t2[i];</span><br><span class="line">		<span class="keyword">if</span>(c[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			c[i] += <span class="number">10</span>;</span><br><span class="line">			c[i + <span class="number">1</span>] --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span>(!c[len] &amp;&amp; len &gt; <span class="number">0</span>) len --;</span><br><span class="line">	<span class="keyword">if</span>(!len)&#123;<span class="comment">//特殊情况的判断 </span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、高精度乘法"><a href="#三、高精度乘法" class="headerlink" title="三、高精度乘法"></a>三、高精度乘法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000000</span></span><br><span class="line"><span class="type">int</span> t1[N], t2[N], c[N];</span><br><span class="line"><span class="type">char</span> a[N], b[N];<span class="comment">// 两个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt; a&gt;&gt; b;<span class="comment">//输入两个数 </span></span><br><span class="line">	<span class="type">int</span> lena = <span class="built_in">strlen</span>(a);</span><br><span class="line">	<span class="type">int</span> lenb = <span class="built_in">strlen</span>(b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lena; ++ i) t1[lena - i] = a[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//存下两个加数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenb; ++ i) t2[lenb - i] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> len = lena + lenb;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lena; ++ i)&#123;<span class="comment">//两层循环依次计算 </span></span><br><span class="line">		<span class="type">int</span> x = <span class="number">0</span>;<span class="comment">//存储进位 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lenb; ++ j)&#123;</span><br><span class="line">			c[i + j - <span class="number">1</span>] += t1[i] * t2[j] + x;<span class="comment">//</span></span><br><span class="line">			x = c[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">			c[i + j - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		c[i + lenb] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!c[len] &amp;&amp; len &gt; <span class="number">1</span>) len --;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、高精度除法"><a href="#四、高精度除法" class="headerlink" title="四、高精度除法"></a>四、高精度除法</h2><h3 id="1-高精度除以低精度"><a href="#1-高精度除以低精度" class="headerlink" title="1.高精度除以低精度"></a>1.高精度除以低精度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000000</span></span><br><span class="line"><span class="type">int</span> t1[N], c[N];</span><br><span class="line"><span class="type">char</span> a[N];<span class="comment">// 两个数</span></span><br><span class="line"><span class="type">int</span> b; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt; a&gt;&gt; b;<span class="comment">//输入两个数 </span></span><br><span class="line">	<span class="type">int</span> lena = <span class="built_in">strlen</span>(a);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lena; ++ i) t1[lena - i] = a[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//存下被除数 </span></span><br><span class="line">	<span class="type">int</span> len = lena;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; -- i)&#123;<span class="comment">//从高位到低位的处理 </span></span><br><span class="line">		c[i] += (x * <span class="number">10</span> + t1[i]) / b;</span><br><span class="line">		x = (x * <span class="number">10</span> + t1[i]) % b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!c[len] &amp;&amp; len &gt; <span class="number">1</span>) len --;<span class="comment">//最高位的判断</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c[i]);<span class="comment">//商 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, x);<span class="comment">//余数 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-高精度除以高精度"><a href="#2-高精度除以高精度" class="headerlink" title="2.高精度除以高精度"></a>2.高精度除以高精度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 305</span></span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];<span class="comment">//anan-1&#x27;&#x27;&#x27;a1-&gt;数字的正常顺序 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> a[])</span></span>&#123;<span class="comment">//读入数据并进行存储 </span></span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt; s;</span><br><span class="line">	a[<span class="number">0</span>] = s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++ i)</span><br><span class="line">		a[i] = s[a[<span class="number">0</span>]-i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a[])</span></span>&#123;<span class="comment">//输出结果函数 </span></span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">		cout&lt;&lt; <span class="string">&#x27;0&#x27;</span>&lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = a[<span class="number">0</span>]; i &gt; <span class="number">0</span>; -- i)</span><br><span class="line">		cout&lt;&lt; a[i];</span><br><span class="line">	cout&lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[])</span></span>&#123;<span class="comment">//比较两个数大小的函数 </span></span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = a[<span class="number">0</span>]; i &gt; <span class="number">0</span>; -- i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &gt; b[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &lt; b[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">numcpy</span><span class="params">(<span class="type">int</span> p[], <span class="type">int</span> q[], <span class="type">int</span> det)</span></span>&#123;<span class="comment">//复制p数组到q数组从det开始的地方</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p[<span class="number">0</span>]; ++ i)</span><br><span class="line">		q[i + det - <span class="number">1</span>] = p[i];</span><br><span class="line">	q[<span class="number">0</span>] = p[<span class="number">0</span>] + det - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Minus</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[])</span></span>&#123;<span class="comment">//减法操作 </span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	flag = <span class="built_in">compare</span>(a, b);</span><br><span class="line">	<span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">		a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; ++ i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] &lt; b[i])&#123;</span><br><span class="line">				a[i + <span class="number">1</span>] --;</span><br><span class="line">				a[i] += <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i] -= b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(a[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; a[a[<span class="number">0</span>]] == <span class="number">0</span>) a[<span class="number">0</span>] --;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">High_accuracy_division</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp[N];</span><br><span class="line">	c[<span class="number">0</span>] = a[<span class="number">0</span>] - b[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = c[<span class="number">0</span>]; i &gt; <span class="number">0</span>; -- i)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="built_in">sizeof</span>(tmp));</span><br><span class="line">		<span class="built_in">numcpy</span>(b, tmp, i);</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">compare</span>(a, tmp) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			c[i] ++;</span><br><span class="line">			<span class="built_in">Minus</span>(a, tmp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(c[<span class="number">0</span>] &gt; <span class="number">0</span> &amp;&amp; c[c[<span class="number">0</span>]] == <span class="number">0</span>)</span><br><span class="line">		c[<span class="number">0</span>] --;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Init</span>(a);</span><br><span class="line">	<span class="built_in">Init</span>(b);</span><br><span class="line">	<span class="built_in">High_accuracy_division</span>(a, b, c);</span><br><span class="line">	<span class="built_in">Print</span>(c);</span><br><span class="line">	<span class="built_in">Print</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、高精度算法的优化思路"><a href="#五、高精度算法的优化思路" class="headerlink" title="五、高精度算法的优化思路"></a>五、高精度算法的优化思路</h2><p><img src="https://img-blog.csdnimg.cn/0dc48c5a34064fc3bee0e0738faef51a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQ3Jlcl9sdQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>高精度</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>（对于换行符）gets和fgets的区别，puts和fputs的区别</title>
    <url>/posts/19585/</url>
    <content><![CDATA[<p><center></center><br><span id="more"></span></p>
<h2 id="转载两篇博客，说的很清楚。"><a href="#转载两篇博客，说的很清楚。" class="headerlink" title="转载两篇博客，说的很清楚。"></a>转载两篇博客，说的很清楚。</h2><p> <a href="https://blog.csdn.net/qq_45849888/article/details/104562038">关于fets与gets</a><br> <a href="https://blog.csdn.net/qq_21835111/article/details/84445302">关于fputs与puts</a></p>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
